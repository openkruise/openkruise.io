"use strict";(globalThis.webpackChunkopenkruise_io=globalThis.webpackChunkopenkruise_io||[]).push([[4431],{25424:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/hot-update-1dd12ed5397ac13cd11a381d2358855c.png"},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var a=t(96540);const r={},s=a.createContext(r);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:n},e.children)}},74170:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"user-manuals/hot-update","title":"Hot Update","description":"Game server update is a crucial part of game server application delivery.","source":"@site/kruisegame/user-manuals/hot-update.md","sourceDirName":"user-manuals","slug":"/user-manuals/hot-update","permalink":"/kruisegame/user-manuals/hot-update","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Odysseus Zhang","lastUpdatedAt":1772264893000,"frontMatter":{},"sidebar":"kruisegame","previous":{"title":"State & OpsState","permalink":"/kruisegame/user-manuals/gameserver-state"},"next":{"title":"Update Strategy","permalink":"/kruisegame/user-manuals/update-strategy"}}');var r=t(74848),s=t(28453);const i={},o="Hot Update",l={},d=[{value:"GameServer &amp; Container",id:"gameserver--container",level:2},{value:"Hot updates of game servers based on in-place update",id:"hot-updates-of-game-servers-based-on-in-place-update",level:2},{value:"In-place update",id:"in-place-update",level:3},{value:"Example Usage",id:"example-usage",level:3},{value:"Reload methods after file hot update",id:"reload-methods-after-file-hot-update",level:3},{value:"Manual batch reload",id:"manual-batch-reload",level:4},{value:"Track the hot update file directory through inotify",id:"track-the-hot-update-file-directory-through-inotify",level:4},{value:"Triggering HTTP requests in the sidecar",id:"triggering-http-requests-in-the-sidecar",level:4},{value:"Fully managed hot reload",id:"fully-managed-hot-reload",level:4},{value:"In-place hot update during server downtime",id:"in-place-hot-update-during-server-downtime",level:3},{value:"Network metadata remains unchanged",id:"network-metadata-remains-unchanged",level:4},{value:"Shared memory is not lost",id:"shared-memory-is-not-lost",level:4}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"hot-update",children:"Hot Update"})}),"\n",(0,r.jsx)(n.p,{children:"Game server update is a crucial part of game server application delivery.\nAs a stateful type of service, game server updates often require higher demands on cloud-native infrastructure.\nThis article mainly introduces how to use OKG's in-place update capability to achieve hot updates of game servers."}),"\n",(0,r.jsx)(n.h2,{id:"gameserver--container",children:"GameServer & Container"}),"\n",(0,r.jsx)(n.p,{children:"Before introducing the hot update method, we may need to clarify the relationship between game servers and containers.\nIn the concept of OKG, a game server (GameServer) can contain multiple containers, each container serving a different function and corresponding to different container images.\nOf course, a game server can also contain only one container.\nWhether a game server contains one or multiple containers corresponds to two different architectural concepts."}),"\n",(0,r.jsx)(n.p,{children:"For game servers with only one container, they are closer to the management approach of virtual machines.\nWhether it is state management or hot updates of small versions, they do not rely on the capabilities of Kubernetes, but follow the traditional management approach.\nFor example, in the single container of a game server, there may be multiple processes, scripts or configuration files.\nThe game engine's resident process is usually implemented by building a new container for new version releases, and updates to new scripts, resources, or configurations often rely on object storage volumes or dynamic pulling of self-developed programs.\nAnd the update situation is judged by the business itself, and the entire process is carried out in a non-cloud-native manner.\nWe call this type of game server a rich container. The problem with hot updates of rich containers is that:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It is impossible to perform cloud-native version management on scripts/resources/configuration files. Since the container image has not changed, the version of the script files running in the current container is unknown to the operations personnel. After the game is launched, the iteration of small versions is very frequent. When a fault occurs, a system without version management will be difficult to locate the problem, which greatly increases the complexity of operations."}),"\n",(0,r.jsx)(n.li,{children:"It is difficult to locate the update status. Even if the files in the container have been updated and replaced, it is difficult to determine whether the current hot update file has been mounted when executing the reload command. The maintenance of the success or failure of this update status needs to be managed by the operations personnel, which also increases the complexity of operations to a certain extent."}),"\n",(0,r.jsx)(n.li,{children:"It is impossible to perform gradual upgrades. When updating, in order to control the scope of impact, it is often necessary to update the game servers with low importance first, and then gradually update the remaining game servers after confirmation. However, it is difficult to achieve gradual release, whether it is through object storage mounts or program pulling. Once there is a problem with a full release, the impact will be significant."}),"\n",(0,r.jsx)(n.li,{children:"When the container is abnormal, the pod rebuilds and pulls up the old version image, and the hot update file is not continuously saved."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For the hot update scenario of game servers, a more ideal approach is to use a multi-container game server architecture, where the hot update part is deployed as a sidecar container along with the main container in the same game server (GameServer), and the two share the hot update files through emptyDir. Only the sidecar container needs to be updated during updates. In this way, the hot update of game servers will be carried out in a cloud-native manner:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The sidecar container image has version attributes, solving the version management problem."}),"\n",(0,r.jsx)(n.li,{children:"After the Kubernetes container update is successful, it is in the Ready state and can perceive whether the sidecar update is successful."}),"\n",(0,r.jsx)(n.li,{children:"OKG provides various update strategies, and the release objects can be controlled according to the release requirements to complete the gradual release."}),"\n",(0,r.jsx)(n.li,{children:"Even if the container is abnormally restarted, the hot update file is continuously saved along with the solidification of the image."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"hot-updates-of-game-servers-based-on-in-place-update",children:"Hot updates of game servers based on in-place update"}),"\n",(0,r.jsx)(n.h3,{id:"in-place-update",children:"In-place update"}),"\n",(0,r.jsx)(n.p,{children:"In standard Kubernetes, application updates are implemented by changing the Image field in the resource object.\nHowever, in the native workload managed by Deployment or StatefulSet, the pod will be rebuilt after updating the Image, and the lifecycle of the pod is coupled with the lifecycle of the container.\nThe multi-container architecture of game server hot updates mentioned earlier becomes a joke under the native workload of Kubernetes."}),"\n",(0,r.jsx)(n.p,{children:"OKG's GameServerSet provides the ability of in-place upgrade, which can update a specific container without recreating the entire game server while ensuring that the entire game server lifecycle remains unchanged.\nDuring the update process of the sidecar container, the game server runs normally, and the players will not be affected."}),"\n",(0,r.jsx)(n.p,{children:"As shown in the figure below, the blue part is the hot update part, and the orange part is the non-hot update part.\nAfter we update the Game Script container from version V1 to version V2, the entire pod will not be rebuilt, and the orange part will not be affected.\nThe Game Engine runs smoothly and normally."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"hot-update.png",src:t(25424).A+"",width:"712",height:"266"})}),"\n",(0,r.jsx)(n.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,r.jsx)(n.p,{children:"In this article, we will use the 2048 web version as an example.\nIn the example, we will see how to update game scripts without affecting the lifecycle of the game server."}),"\n",(0,r.jsx)(n.p,{children:"Deploy the game server with a sidecar container using GameServerSet as the game server workload, and set:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Choose in-place upgrade as the pod update strategy"}),"\n",(0,r.jsx)(n.li,{children:"Use AlibabaCloud-SLB network model to expose services"}),"\n",(0,r.jsxs)(n.li,{children:["There are two containers, where app-2048 is the main container that carries the main game logic, and the sidecar is the companion container that stores the hot update files. The two containers share a file directory through emptyDir.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"When the sidecar starts, it synchronizes the files in the directory that stores the hot update files (/app/js) to the shared directory (/app/scripts), and sleeps without exiting after synchronization."}),"\n",(0,r.jsx)(n.li,{children:"The app-2048 container uses the game scripts under the /var/www/html/js directory."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cat <<EOF | kubectl apply -f -\napiVersion: game.kruise.io/v1alpha1\nkind: GameServerSet\nmetadata:\n  name: gss-2048\n  namespace: default\nspec:\n  replicas: 1\n  updateStrategy:\n    rollingUpdate:\n      podUpdatePolicy: InPlaceIfPossible\n  network:\n    networkType: AlibabaCloud-SLB\n    networkConf:\n      - name: SlbIds\n        value: lb-bp1oqahx3jnr7j3f6vyp8\n      - name: PortProtocols\n        value: 80/TCP\n  gameServerTemplate:\n    spec:\n      containers:\n        - image: registry.cn-beijing.aliyuncs.com/acs/2048:v1.0\n          name: app-2048\n          volumeMounts:\n            - name: shared-dir\n              mountPath: /var/www/html/js\n        - image: registry.cn-beijing.aliyuncs.com/acs/2048-sidecar:v1.0\n          name: sidecar\n          args:\n            - bash\n            - -c\n            - rsync -aP /app/js/* /app/scripts/ && while true; do echo 11;sleep 2; done\n          volumeMounts:\n            - name: shared-dir\n              mountPath: /app/scripts\n      volumes:\n        - name: shared-dir\n          emptyDir: {}\nEOF\n"})}),"\n",(0,r.jsx)(n.p,{children:"Create one GameServer and its corresponding Pod."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"NAME          STATE   OPSSTATE   DP    UP   AGE\ngss-2048-0    Ready   None       0     0    13s\n\nkubectl get pod\nNAME          READY   STATUS    RESTARTS   AGE\ngss-2048-0    2/2     Running   0          13s\n"})}),"\n",(0,r.jsxs)(n.p,{children:["At this point, access the game webpage (the game server network-related content can refer to the network model documentation), and when the game ends, the ",(0,r.jsx)(n.code,{children:"Game over!"})," message will be displayed."]}),"\n",(0,r.jsx)("img",{src:t(85742).A,style:{height:"600px",width:"400px"}}),"\n",(0,r.jsxs)(n.p,{children:["Next, we want to update the game server script to change the display message when the game ends to ",(0,r.jsx)(n.code,{children:"*_* Game over!"})]}),"\n",(0,r.jsx)(n.p,{children:"Modify the corresponding script file html_actuator.js, and build a new sidecar image, naming the image tag as v2.0. (In actual production, this process can be completed through the CI process.)"}),"\n",(0,r.jsx)(n.p,{children:"After building & pushing the image, only need to update the container image tag corresponding to the GameServerSet."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"kubectl edit gss gss-2048\n...\n      - image: registry.cn-beijing.aliyuncs.com/acs/2048-sidecar:v2.0\n        name: sidecar\n...\n"})}),"\n",(0,r.jsx)(n.p,{children:"After a period of time, it was noticed that the gs has changed from Updating to Ready, the Pod has been updated, the restarts count has changed to 1, but the Age has not decreased."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"kubectl get pod\nNAME             READY   STATUS    RESTARTS      AGE\ngss-2048-0       2/2     Running   1 (33s ago)   8m55s\n"})}),"\n",(0,r.jsx)(n.p,{children:"At this point, execute the reload command on the app-2048 container."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"kubectl exec gss-2048-0 -c app-2048 -- /usr/sbin/nginx -s reload\n"})}),"\n",(0,r.jsx)(n.p,{children:"Open an incognito browser, play the game, and the updated message will be displayed when the game ends."}),"\n",(0,r.jsx)("img",{src:t(88165).A,style:{height:"600px",width:"400px"}}),"\n",(0,r.jsx)(n.h3,{id:"reload-methods-after-file-hot-update",children:"Reload methods after file hot update"}),"\n",(0,r.jsx)(n.p,{children:"In the example above, the exec command was used to reload a single pod.\nHowever, when managing in batches, the reload operation becomes too cumbersome and complex.\nBelow are a few file hot reload methods for reference."}),"\n",(0,r.jsx)(n.h4,{id:"manual-batch-reload",children:"Manual batch reload"}),"\n",(0,r.jsxs)(n.p,{children:["When all game servers are updated to Ready, use the batch management tool ",(0,r.jsx)(n.code,{children:"kubectl-pexec"})," to execute the exec reload command in the container in batches."]}),"\n",(0,r.jsx)(n.h4,{id:"track-the-hot-update-file-directory-through-inotify",children:"Track the hot update file directory through inotify"}),"\n",(0,r.jsx)(n.p,{children:"inotify is a Linux file monitoring system framework. Through inotify, the main game server business container can listen for changes in files in the hot update file directory, triggering an update."}),"\n",(0,r.jsx)(n.p,{children:"To use inotify, you need to install inotify-tools in the container:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"apt-get install inotify-tools\n"})}),"\n",(0,r.jsx)(n.p,{children:"Taking the 2048 game as an example, on top of the original image, the app-2048 container listens to the /var/www/html/js/ directory, and automatically executes the reload command when it detects changes in the file."}),"\n",(0,r.jsx)(n.p,{children:"The script is shown below and can be executed when the container starts.\nIt is worth noting that the reload command should be idempotent."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"inotifywait -mrq --timefmt '%d/%m/%y %H:%M' --format '%T %w%f%e' -e modify,delete,create,attrib /var/www/html/js/ |  while read file\ndo\n\t/usr/sbin/nginx -s reload\n\techo \"reload successfully\"\ndone\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The above program is integrated into the image and a new image ",(0,r.jsx)(n.code,{children:"registry.cn-beijing.aliyuncs.com/acs/2048:v1.0-inotify"})," is built.\nIn the subsequent experiment (with other fields unchanged), it can be observed that the entire hot update process no longer requires manual input of the reload command after the sidecar image is replaced with v2.0.\nThe complete YAML is as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"kind: GameServerSet\nmetadata:\n  name: gss-2048\n  namespace: default\nspec:\n  replicas: 1\n  updateStrategy:\n    rollingUpdate:\n      podUpdatePolicy: InPlaceIfPossible\n  network:\n    networkType: AlibabaCloud-SLB\n    networkConf:\n      - name: SlbIds\n        value: lb-bp1oqahx3jnr7j3f6vyp8\n      - name: PortProtocols\n        value: 80/TCP\n  gameServerTemplate:\n    spec:\n      containers:\n        - image: registry.cn-beijing.aliyuncs.com/acs/2048:v1.0-inotify\n          name: app-2048\n          volumeMounts:\n            - name: shared-dir\n              mountPath: /var/www/html/js\n        - image: registry.cn-beijing.aliyuncs.com/acs/2048-sidecar:v1.0 #Replace with v2.0 during hot update\n          name: sidecar\n          args:\n            - bash\n            - -c\n            - rsync -aP /app/js/* /app/scripts/ && while true; do echo 11;sleep 2; done\n          volumeMounts:\n            - name: shared-dir\n              mountPath: /app/scripts\n      volumes:\n        - name: shared-dir\n          emptyDir: {}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"triggering-http-requests-in-the-sidecar",children:"Triggering HTTP requests in the sidecar"}),"\n",(0,r.jsx)(n.p,{children:"The main game server business container exposes an HTTP interface, and the sidecar sends a reload request to 127.0.0.1 after it successfully starts.\nDue to the fact that the containers in the pod share the same network namespace, the main container will perform file reloads upon receiving the request."}),"\n",(0,r.jsx)(n.p,{children:"Taking the 2048 game as an example, on top of the original image:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The app-2048 container adds a reload interface. Below is an example of the JS code:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"var http = require('http');\nvar exec = require('child_process').exec;\n\nvar server = http.createServer(function(req, res) {\n  if (req.url === '/reload') {\n    exec('/usr/sbin/nginx -s reload', function(error, stdout, stderr) {\n      if (error) {\n        console.error('exec error: ' + error);\n        res.statusCode = 500;\n        res.end('Error: ' + error.message);\n        return;\n      }\n      console.log('stdout: ' + stdout);\n      console.error('stderr: ' + stderr);\n      res.statusCode = 200;\n      res.end();\n    });\n  } else {\n    res.statusCode = 404;\n    res.end('Not found');\n  }\n});\n\nserver.listen(3000, function() {\n  console.log('Server is running on port 3000');\n});\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"At the same time, the sidecar container adds a request script request.sh. After the container is started, the postStart hook is used to add the command to send the request, as shown below:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"...\n          name: sidecar\n          lifecycle:\n            postStart:\n              exec:\n                command:\n                  - bash\n                  - -c\n                  - ./request.sh\n...\n"})}),"\n",(0,r.jsx)(n.p,{children:"The corresponding request.sh script is shown below, which has a retry mechanism and will exit only after confirming that the reload was successful."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:'#!/bin/bash\n\n# \u5faa\u73af\u53d1\u9001 HTTP \u8bf7\u6c42\uff0c\u76f4\u5230\u670d\u52a1\u5668\u8fd4\u56de\u6210\u529f\u54cd\u5e94\u4e3a\u6b62\nwhile true; do\n  response=$(curl -s -w "%{http_code}" http://localhost:3000/reload)\n  if [[ $response -eq 200 ]]; then\n    echo "Server reloaded successfully!"\n    break\n  else\n    echo "Server reload failed, response code: $response"\n  fi\n  sleep 1\ndone\n'})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In this way, automatic reload can be achieved after file updates."}),"\n",(0,r.jsx)(n.p,{children:"The above program is integrated into the image and a new image is built as follows:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"registry.cn-beijing.aliyuncs.com/acs/2048:v1.0-http"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"registry.cn-beijing.aliyuncs.com/acs/2048-sidecar:v1.0-http"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"registry.cn-beijing.aliyuncs.com/acs/2048-sidecar:v2.0-http"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Replace the new image and run the experiment again (note that the sidecar in the YAML needs to add the lifecycle field).\nAfter replacing the v1.0-http sidecar image with v2.0-http, it can be observed that the entire hot update process no longer requires manual input of the reload command.\nThe complete YAML is as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"kind: GameServerSet\nmetadata:\n  name: gss-2048\n  namespace: default\nspec:\n  replicas: 1\n  updateStrategy:\n    rollingUpdate:\n      podUpdatePolicy: InPlaceIfPossible\n  network:\n    networkType: AlibabaCloud-SLB\n    networkConf:\n      - name: SlbIds\n        value: lb-bp1oqahx3jnr7j3f6vyp8\n      - name: PortProtocols\n        value: 80/TCP\n  gameServerTemplate:\n    spec:\n      containers:\n        - image: registry.cn-beijing.aliyuncs.com/acs/2048:v1.0-http\n          name: app-2048\n          volumeMounts:\n            - name: shared-dir\n              mountPath: /var/www/html/js\n        - image: registry.cn-beijing.aliyuncs.com/acs/2048-sidecar:v1.0-http #Replace with v2.0-http during hot update\n          name: sidecar\n          lifecycle:\n            postStart:\n              exec:\n                command:\n                  - bash\n                  - -c\n                  - ./request.sh\n          args:\n            - bash\n            - -c\n            - rsync -aP /app/js/* /app/scripts/ && while true; do echo 11;sleep 2; done\n          volumeMounts:\n            - name: shared-dir\n              mountPath: /app/scripts\n      volumes:\n        - name: shared-dir\n          emptyDir: {}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"fully-managed-hot-reload",children:"Fully managed hot reload"}),"\n",(0,r.jsx)(n.p,{children:"OKG has the ability to trigger the execution of commands in containers.\nBased on this feature, OKG can provide fully automated hot update capabilities, allowing users to no longer overly concern themselves with hot reload issues.\nIf you have such requirements, you can submit an issue on GitHub and discuss the OKG hot reload feature development roadmap with community developers."}),"\n",(0,r.jsx)(n.h3,{id:"in-place-hot-update-during-server-downtime",children:"In-place hot update during server downtime"}),"\n",(0,r.jsx)(n.p,{children:"In a gaming scenario, hot update in a narrow sense refers to updates that do not affect players' normal gameplay without stopping the server.\nHowever, in some scenarios, game server downtime updates also require in-place upgrade capabilities."}),"\n",(0,r.jsx)(n.h4,{id:"network-metadata-remains-unchanged",children:"Network metadata remains unchanged"}),"\n",(0,r.jsx)(n.p,{children:"The stateful nature of game servers is often reflected in network information.\nSince each game server is unique and cannot use the concept of k8s service load balancing, game developers often implement routing and distribution mechanisms based on IP.\nIn this case, when updating the game, we need to avoid changes in the game server IP information.\nOKG's in-place upgrade capability can meet the above requirements."}),"\n",(0,r.jsx)(n.h4,{id:"shared-memory-is-not-lost",children:"Shared memory is not lost"}),"\n",(0,r.jsx)(n.p,{children:"After the game server is created, it is scheduled to a certain host, and the game business uses shared memory to reduce data write latency, so that the game server adds a layer of cache locally.\nDuring game server updates, although there may be a short service interruption, due to the existence of the cache, the game server has a fast termination and startup speed, and the downtime is greatly reduced.\nThe implementation of shared memory also depends on OKG's in-place upgrade capabilities to ensure that the corresponding cache data is not lost."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},85742:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/2048-v1-1be743c38e1adf20a9d80b02de03ba65.png"},88165:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/2048-v2-11052c4849ab4eda2bf0136ab1deb408.png"}}]);