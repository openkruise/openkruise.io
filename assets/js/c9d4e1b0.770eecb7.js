"use strict";(self.webpackChunkopenkruise_io=self.webpackChunkopenkruise_io||[]).push([[8759],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var a=n(96540);const r={},i=a.createContext(r);function s(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:t},e.children)}},99473:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"user-manuals/crd-field-description","title":"CRD Field Description","description":"GameServerSet","source":"@site/kruisegame/user-manuals/crd-field-description.md","sourceDirName":"user-manuals","slug":"/user-manuals/crd-field-description","permalink":"/kruisegame/user-manuals/crd-field-description","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Gautam Manchandani","lastUpdatedAt":1752802431000,"frontMatter":{},"sidebar":"kruisegame","previous":{"title":"GameServer Schedulers","permalink":"/kruisegame/user-manuals/gameserver-scheduler"},"next":{"title":"FAQ","permalink":"/kruisegame/user-manuals/faq"}}');var r=n(74848),i=n(28453);const s={},o="CRD Field Description",l={},d=[{value:"GameServerSet",id:"gameserverset",level:2},{value:"GameServerSetSpec",id:"gameserversetspec",level:3},{value:"GameServerTemplate",id:"gameservertemplate",level:4},{value:"UpdateStrategy",id:"updatestrategy",level:4},{value:"ScaleStrategy",id:"scalestrategy",level:4},{value:"ServiceQualities",id:"servicequalities",level:4},{value:"Network",id:"network",level:4},{value:"Lifecycle",id:"lifecycle",level:4},{value:"GameServerSetStatus",id:"gameserversetstatus",level:3},{value:"GameServer",id:"gameserver",level:2},{value:"GameServerSpec",id:"gameserverspec",level:3},{value:"GameServerStatus",id:"gameserverstatus",level:3}];function c(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"crd-field-description",children:"CRD Field Description"})}),"\n",(0,r.jsx)(t.h2,{id:"gameserverset",children:"GameServerSet"}),"\n",(0,r.jsx)(t.h3,{id:"gameserversetspec",children:"GameServerSetSpec"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'type GameServerSetSpec struct {\n    // The number of game servers. Must be specified, with a minimum value of 0.\n    Replicas *int32 `json:"replicas"`\n\n    // Game server template. The new game server will be created with the parameters defined in GameServerTemplate.\n    GameServerTemplate   GameServerTemplate `json:"gameServerTemplate,omitempty"`\n    \n    // serviceName is the name of the service that governs this GameServerSet.\n\t// This service must exist before the GameServerSet, and is responsible for\n\t// the network identity of the set. Pods get DNS/hostnames that follow the\n\t// pattern: pod-specific-string.serviceName.default.svc.cluster.local\n\t// where "pod-specific-string" is managed by the GameServerSet controller.\n\tServiceName string `json:"serviceName,omitempty"`\n\n    // Reserved game server IDs, optional. If specified, existing game servers with those IDs will be deleted,\n    // and new game servers will not be created with those IDs.\n\tReserveGameServerIds []intstr.IntOrString `json:"reserveGameServerIds,omitempty"`\n\n    // Custom service qualities for game servers.\n    ServiceQualities     []ServiceQuality   `json:"serviceQualities,omitempty"`\n\n    // Batch update strategy for game servers.\n    UpdateStrategy       UpdateStrategy     `json:"updateStrategy,omitempty"`\n \n    // Horizontal scaling strategy for game servers.\n    ScaleStrategy        ScaleStrategy      `json:"scaleStrategy,omitempty"`\n\n    // Network settings for game server access layer.\n    Network              *Network           `json:"network,omitempty"`\n    \n    // Lifecycle hook defined by users\n    Lifecycle            *appspub.Lifecycle `json:"lifecycle,omitempty"`\n    \n    // PersistentVolumeClaimRetentionPolicy describes the policy used for PVCs created from\n\t// the StatefulSet VolumeClaimTemplates. This requires the\n\t// StatefulSetAutoDeletePVC feature gate to be enabled, which is alpha.\n\tPersistentVolumeClaimRetentionPolicy *kruiseV1beta1.StatefulSetPersistentVolumeClaimRetentionPolicy `json:"persistentVolumeClaimRetentionPolicy,omitempty"`\n}\n\n'})}),"\n",(0,r.jsx)(t.h4,{id:"gameservertemplate",children:"GameServerTemplate"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'type GameServerTemplate struct {\n    // All fields inherited from PodTemplateSpec. More details: https://pkg.go.dev/k8s.io/api/core/v1#PodTemplateSpec\n    corev1.PodTemplateSpec `json:",inline"`\n    \n    // Requests and claims for persistent volumes.\n    VolumeClaimTemplates   []corev1.PersistentVolumeClaim `json:"volumeClaimTemplates,omitempty"`\n    \n    // ReclaimPolicy indicates the reclaim policy for GameServer.\n    // Default is Cascade.\n    ReclaimPolicy GameServerReclaimPolicy `json:"reclaimPolicy,omitempty"`\n}\n\ntype GameServerReclaimPolicy string\n\nconst (\n    // CascadeGameServerReclaimPolicy indicates that GameServer is deleted when the pod is deleted.\n    // The age of GameServer is exactly the same as that of the pod.\n    CascadeGameServerReclaimPolicy GameServerReclaimPolicy = "Cascade"\n    \n    // DeleteGameServerReclaimPolicy indicates that GameServers will be deleted when replicas of GameServerSet decreases.\n    // The GameServer will not be deleted when the corresponding pod is deleted due to manual deletion, update, eviction, etc.\n    DeleteGameServerReclaimPolicy GameServerReclaimPolicy = "Delete"\n)\n'})}),"\n",(0,r.jsx)(t.h4,{id:"updatestrategy",children:"UpdateStrategy"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'type UpdateStrategy struct {\n    // Type indicates the type of the StatefulSetUpdateStrategy.\n    // Default is RollingUpdate.\n    // +optional\n    Type apps.StatefulSetUpdateStrategyType `json:"type,omitempty"`\n\n    // RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.\n    // +optional\n    RollingUpdate *RollingUpdateStatefulSetStrategy `json:"rollingUpdate,omitempty"`\n}\n\ntype RollingUpdateStatefulSetStrategy struct {\n    // Partition indicates the ordinal at which the StatefulSet should be partitioned by default.\n    // But if unorderedUpdate has been set:\n    //   - Partition indicates the number of pods with non-updated revisions when rolling update.\n    //   - It means controller will update $(replicas - partition) number of pod.\n    // Default value is 0.\n    // +optional\n    Partition *int32 `json:"partition,omitempty"`\n    \n    // The maximum number of pods that can be unavailable during the update.\n    // Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\n    // Absolute number is calculated from percentage by rounding down.\n    // Also, maxUnavailable can just be allowed to work with Parallel podManagementPolicy.\n    // Defaults to 1.\n    // +optional\n    MaxUnavailable *intstr.IntOrString `json:"maxUnavailable,omitempty"`\n    \n    // PodUpdatePolicy indicates how pods should be updated\n    // Default value is "ReCreate"\n    // +optional\n    PodUpdatePolicy kruiseV1beta1.PodUpdateStrategyType `json:"podUpdatePolicy,omitempty"`\n    \n    // Paused indicates that the StatefulSet is paused.\n    // Default value is false\n    // +optional\n    Paused bool `json:"paused,omitempty"`\n    \n    // UnorderedUpdate contains strategies for non-ordered update.\n    // If it is not nil, pods will be updated with non-ordered sequence.\n    // Noted that UnorderedUpdate can only be allowed to work with Parallel podManagementPolicy\n    // +optional\n    // UnorderedUpdate *kruiseV1beta1.UnorderedUpdateStrategy `json:"unorderedUpdate,omitempty"`\n    \n    // InPlaceUpdateStrategy contains strategies for in-place update.\n    // +optional\n    InPlaceUpdateStrategy *appspub.InPlaceUpdateStrategy `json:"inPlaceUpdateStrategy,omitempty"`\n    \n    // MinReadySeconds indicates how long will the pod be considered ready after it\'s updated.\n    // MinReadySeconds works with both OrderedReady and Parallel podManagementPolicy.\n    // It affects the pod scale up speed when the podManagementPolicy is set to be OrderedReady.\n    // Combined with MaxUnavailable, it affects the pod update speed regardless of podManagementPolicy.\n    // Default value is 0, max is 300.\n    // +optional\n    MinReadySeconds *int32 `json:"minReadySeconds,omitempty"`\n}\n\ntype InPlaceUpdateStrategy struct {\n    // GracePeriodSeconds is the timespan between set Pod status to not-ready and update images in Pod spec\n    // when in-place update a Pod.\n    GracePeriodSeconds int32 `json:"gracePeriodSeconds,omitempty"`\n}\n'})}),"\n",(0,r.jsx)(t.h4,{id:"scalestrategy",children:"ScaleStrategy"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'\ntype ScaleStrategy struct {\n    // The maximum number of pods that can be unavailable during scaling.\n    // Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\n    // Absolute number is calculated from percentage by rounding down.\n    // It can just be allowed to work with Parallel podManagementPolicy.\n    MaxUnavailable *intstr.IntOrString `json:"maxUnavailable,omitempty"`\n\n    // ScaleDownStrategyType indicates the scaling down strategy, include two types: General & ReserveIds\n    // General will first consider the ReserveGameServerIds field when game server scaling down. \n    // When the number of reserved game servers does not meet the scale down number, continue to \n    // select and delete the game servers from the current game server list.\n    // ReserveIds will backfill the sequence numbers into ReserveGameServerIds field when\n    // GameServers scale down, whether set by ReserveGameServerIds field or the GameServerSet \n    // controller chooses to remove it.\n    // Default is General\n    // +optional\n    ScaleDownStrategyType ScaleDownStrategyType `json:"scaleDownStrategyType,omitempty"`\n}\n'})}),"\n",(0,r.jsx)(t.h4,{id:"servicequalities",children:"ServiceQualities"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'type ServiceQuality struct {\n    // Inherits all fields from corev1.Probe. More details: https://pkg.go.dev/k8s.io/api/core/v1#Probe\n    corev1.Probe  `json:",inline"`\n    \n    // Custom name for the service quality, distinguishes different service qualities that are defined.\n    Name          string `json:"name"`\n    \n    // Name of the container to be probed.\n    ContainerName string `json:"containerName,omitempty"`\n\n    // Whether to make GameServerSpec not change after the ServiceQualityAction is executed.\n    // When Permanent is true, regardless of the detection results, ServiceQualityAction will only be executed once.\n    // When Permanent is false, ServiceQualityAction can be executed again even though ServiceQualityAction has been executed.\n    Permanent            bool                   `json:"permanent"`\n    \n    // Corresponding actions to be executed for the service quality.\n    ServiceQualityAction []ServiceQualityAction `json:"serviceQualityAction,omitempty"`\n}\n\ntype ServiceQualityAction struct {\n    // Defines to change the GameServerSpec field when the detection is true/false.\n    State          bool `json:"state"`\n    \n    // Result indicate the probe message returned by the script.\n\t// When Result is defined, it would exec action only when the according Result is actually returns.\n\tResult         string `json:"result,omitempty"`\n\t\n    GameServerSpec `json:",inline"`\n    \n    Annotations    map[string]string `json:"annotations,omitempty"`\n\tLabels         map[string]string `json:"labels,omitempty"`\n}\n'})}),"\n",(0,r.jsx)(t.h4,{id:"network",children:"Network"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'type Network struct {\n    // Different network types correspond to different network plugins.\n    NetworkType string              `json:"networkType,omitempty"`\n\n    // Different network types need to fill in different network parameters.\n    NetworkConf []NetworkConfParams `json:"networkConf,omitempty"`\n}\n\ntype NetworkConfParams KVParams\n\ntype KVParams struct {\n    // Parameter name, the name is determined by the network plugin\n    Name  string `json:"name,omitempty"`\n\n    // Parameter value, the format is determined by the network plugin\n    Value string `json:"value,omitempty"`\n}\n'})}),"\n",(0,r.jsx)(t.h4,{id:"lifecycle",children:"Lifecycle"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'// Lifecycle contains the hooks for Pod lifecycle.\ntype Lifecycle struct {\n\t// PreDelete is the hook before Pod to be deleted.\n\tPreDelete *LifecycleHook `json:"preDelete,omitempty"`\n\t// InPlaceUpdate is the hook before Pod to update and after Pod has been updated.\n\tInPlaceUpdate *LifecycleHook `json:"inPlaceUpdate,omitempty"`\n}\n\ntype LifecycleHook struct {\n\tLabelsHandler     map[string]string `json:"labelsHandler,omitempty"`\n\tFinalizersHandler []string          `json:"finalizersHandler,omitempty"`\n\t// MarkPodNotReady = true means:\n\t// - Pod will be set to \'NotReady\' at preparingDelete/preparingUpdate state.\n\t// - Pod will be restored to \'Ready\' at Updated state if it was set to \'NotReady\' at preparingUpdate state.\n\t// Default to false.\n\tMarkPodNotReady bool `json:"markPodNotReady,omitempty"`\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"gameserversetstatus",children:"GameServerSetStatus"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'type GameServerSetStatus struct {\n    // The iteration version of the GameServerSet observed by the controller.\n    ObservedGeneration int64 `json:"observedGeneration,omitempty"`\n\n    // The number of game servers.\n    Replicas                int32  `json:"replicas"`\n\n    // The number of game servers that are ready.\n    ReadyReplicas           int32  `json:"readyReplicas"`\n\n    // The number of game servers that are available.\n    AvailableReplicas       int32  `json:"availableReplicas"`\n\n    // The current number of game servers.\n    CurrentReplicas         int32  `json:"currentReplicas"`\n\n    // The number of game servers that have been updated.\n    UpdatedReplicas         int32  `json:"updatedReplicas"`\n\n    // The number of game servers that have been updated and are ready.\n    UpdatedReadyReplicas    int32  `json:"updatedReadyReplicas,omitempty"`\n\n    // The number of game servers that are in Maintaining state.\n    MaintainingReplicas     *int32 `json:"maintainingReplicas,omitempty"`\n\n    // The number of game servers that are in WaitToBeDeleted state.\n    WaitToBeDeletedReplicas *int32 `json:"waitToBeDeletedReplicas,omitempty"`\n    \n    // The number of game servers that are in PreDelete state.\n    PreDeleteReplicas       *int32 `json:"preDeleteReplicas,omitempty"`\n\n    // The label selector used to query game servers that should match the replica count used by HPA.\n    LabelSelector string `json:"labelSelector,omitempty"`\n}\n\n'})}),"\n",(0,r.jsx)(t.h2,{id:"gameserver",children:"GameServer"}),"\n",(0,r.jsx)(t.h3,{id:"gameserverspec",children:"GameServerSpec"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'type GameServerSpec struct {\n   // The O&M state of the game server, not pod runtime state, more biased towards the state of the game itself. The states can be any user-defined value. \n   // At the same time, OKG retains some opsState values, which have different meanings and functions, including:\n   // None - the default value, indicating that there are no exceptions or special states\n   // WaitToBeDeleted - gs has the highest scaling priority and will be automatically recycled after configuring the automatic scaling policy\n   // Maintaining \u2014\u2014 gs scaling has the lowest priority\n   // Allocated \u2014\u2014 gs reduction priority is greater than Maintaining and less than None\n   // Kill - gs set to Kill will be deleted\n   OpsState         OpsState            `json:"opsState,omitempty"`\n\n   // Update priority. If the priority is higher, it will be updated first.\n   UpdatePriority   *intstr.IntOrString `json:"updatePriority,omitempty"`\n\n   // Deletion priority. If the priority is higher, it will be deleted first.\n   DeletionPriority *intstr.IntOrString `json:"deletionPriority,omitempty"`\n\n   // Whether to perform network isolation and cut off the access layer network\n   // Default is false\n   NetworkDisabled  bool                `json:"networkDisabled,omitempty"`\n   \n   // Containers can be used to make the corresponding GameServer container fields\n   // different from the fields defined by GameServerTemplate in GameServerSetSpec.\n   Containers []GameServerContainer `json:"containers,omitempty"`\n}\n\ntype GameServerContainer struct {\n    // Name indicates the name of the container to update.\n    Name string `json:"name"`\n    \n    // Image indicates the image of the container to update.\n    // When Image updated, pod.spec.containers[*].image will be updated immediately.\n    Image string `json:"image,omitempty"`\n    \n    // Resources indicates the resources of the container to update.\n    // When Resources updated, pod.spec.containers[*].Resources will be not updated immediately,\n    // which will be updated when pod recreate.\n    Resources corev1.ResourceRequirements `json:"resources,omitempty"`\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"gameserverstatus",children:"GameServerStatus"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'type GameServerStatus struct {\n    // Expected game server status\n    DesiredState              GameServerState           `json:"desiredState,omitempty"`\n\n    // The actual status of the current game server\n    CurrentState              GameServerState           `json:"currentState,omitempty"`\n\n    // network status information\n    NetworkStatus             NetworkStatus             `json:"networkStatus,omitempty"`\n\n    // The game server corresponds to the pod status\n    PodStatus                 corev1.PodStatus          `json:"podStatus,omitempty"`\n\n    // Service quality status of game server\n    ServiceQualitiesCondition []ServiceQualityCondition `json:"serviceQualitiesConditions,omitempty"`\n    \n    // Conditions is an array of current observed conditions related with GameServer.\n    // Currently support pod Conditions / node Conditions / pv Conditions\n\tConditions []GameServerCondition `json:"conditions,omitempty" `\n\n    // Current update priority\n    UpdatePriority     *intstr.IntOrString `json:"updatePriority,omitempty"`\n\n    // Current deletion priority\n    DeletionPriority   *intstr.IntOrString `json:"deletionPriority,omitempty"`\n\n    // Last change time\n    LastTransitionTime metav1.Time         `json:"lastTransitionTime,omitempty"`\n}\n'})})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);