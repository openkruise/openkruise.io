"use strict";(self.webpackChunkopenkruise_io=self.webpackChunkopenkruise_io||[]).push([[9112],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var l=i(96540);const s={},t=l.createContext(s);function a(e){const n=l.useContext(t);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),l.createElement(t.Provider,{value:n},e.children)}},79925:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>r});const l=JSON.parse('{"id":"user-manuals/cloneset","title":"CloneSet","description":"This controller provides advanced features to efficiently manage stateless applications in large-scale scenarios that","source":"@site/versioned_docs/version-v1.8/user-manuals/cloneset.md","sourceDirName":"user-manuals","slug":"/user-manuals/cloneset","permalink":"/docs/user-manuals/cloneset","draft":false,"unlisted":false,"editUrl":"https://github.com/openkruise/openkruise.io/edit/master/docs/user-manuals/cloneset.md","tags":[],"version":"v1.8","lastUpdatedBy":"Zhen Zhang","lastUpdatedAt":1751855500000,"frontMatter":{"title":"CloneSet"},"sidebar":"docs","previous":{"title":"InPlace Update","permalink":"/docs/core-concepts/inplace-update"},"next":{"title":"Advanced StatefulSet","permalink":"/docs/user-manuals/advancedstatefulset"}}');var s=i(74848),t=i(28453);const a={title:"CloneSet"},o=void 0,d={},r=[{value:"Scale features",id:"scale-features",level:2},{value:"Support PVCs",id:"support-pvcs",level:3},{value:"When volumeClaimTemplates changed, always recreate pods and related volumes",id:"when-volumeclaimtemplates-changed-always-recreate-pods-and-related-volumes",level:4},{value:"Selective Pod deletion",id:"selective-pod-deletion",level:3},{value:"Deletion Sequence",id:"deletion-sequence",level:3},{value:"Pod deletion cost",id:"pod-deletion-cost",level:4},{value:"Deletion by Spread Constraints",id:"deletion-by-spread-constraints",level:4},{value:"Short hash label",id:"short-hash-label",level:3},{value:"Scale up with rate limit",id:"scale-up-with-rate-limit",level:3},{value:"Update features",id:"update-features",level:2},{value:"Update types",id:"update-types",level:3},{value:"Template and revision",id:"template-and-revision",level:3},{value:"Partition",id:"partition",level:3},{value:"Rollback by partition",id:"rollback-by-partition",level:4},{value:"MaxUnavailable",id:"maxunavailable",level:3},{value:"MaxSurge",id:"maxsurge",level:3},{value:"Update sequence",id:"update-sequence",level:3},{value:"priority",id:"priority",level:4},{value:"scatter",id:"scatter",level:4},{value:"Paused update",id:"paused-update",level:3},{value:"In-Place Update Support for Modifying Resources",id:"in-place-update-support-for-modifying-resources",level:3},{value:"Notes",id:"notes",level:4},{value:"Pre-download image for in-place update",id:"pre-download-image-for-in-place-update",level:3},{value:"Lifecycle hook",id:"lifecycle-hook",level:2},{value:"MarkPodNotReady",id:"markpodnotready",level:3},{value:"State circulation",id:"state-circulation",level:3},{value:"Example for user controller logic",id:"example-for-user-controller-logic",level:3},{value:"Scaling with PreparingDelete",id:"scaling-with-preparingdelete",level:3},{value:"Performance optimization",id:"performance-optimization",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["This controller provides advanced features to efficiently manage stateless applications in large-scale scenarios that\ndo not have instance order requirement during scaling and rollout.\nAnalogously, CloneSet can be recognized as an enhanced version of upstream ",(0,s.jsx)(n.code,{children:"Deployment"})," workload, but it does many more."]}),"\n",(0,s.jsxs)(n.p,{children:["As name suggests, CloneSet is a ",(0,s.jsxs)(n.a,{href:"/blog/workload-classification-guidance",children:[(0,s.jsx)(n.strong,{children:"Set"})," -suffix controller"]})," which\nmanages Pods directly. A sample CloneSet yaml looks like following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nmetadata:\n  labels:\n    app: sample\n  name: sample\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: sample\n  template:\n    metadata:\n      labels:\n        app: sample\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:alpine\n"})}),"\n",(0,s.jsx)(n.h2,{id:"scale-features",children:"Scale features"}),"\n",(0,s.jsx)(n.h3,{id:"support-pvcs",children:"Support PVCs"}),"\n",(0,s.jsxs)(n.p,{children:["CloneSet allows user to define PVC templates ",(0,s.jsx)(n.code,{children:"volumeClaimTemplates"})," in ",(0,s.jsx)(n.code,{children:"CloneSetSpec"}),", which can support PVCs per Pod.\nThis cannot be done with ",(0,s.jsx)(n.code,{children:"Deployment"}),". If not specified, CloneSet will only create Pods without PVCs."]}),"\n",(0,s.jsx)(n.p,{children:"A few reminders:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Each PVC created by CloneSet has an owner reference. So when a CloneSet has been deleted, its PVCs will be cascading deleted."}),"\n",(0,s.jsxs)(n.li,{children:['Each Pod and PVC created by CloneSet has a "apps.kruise.io/cloneset-instance-id" label key. The associated Pod and PVC will have the same ',(0,s.jsx)(n.strong,{children:"instance-id"}),". They use the same string as label value which is composed of a unique  ",(0,s.jsx)(n.strong,{children:"instance-id"})," as suffix of the CloneSet name."]}),"\n",(0,s.jsx)(n.li,{children:"When a Pod has been deleted by CloneSet controller, all PVCs related to it will be deleted together."}),"\n",(0,s.jsxs)(n.li,{children:["When a Pod has been deleted manually, all PVCs related to the Pod are preserved, and CloneSet controller will create a new Pod with the same ",(0,s.jsx)(n.strong,{children:"instance-id"})," and reuse the PVCs."]}),"\n",(0,s.jsxs)(n.li,{children:["When a Pod is updated using ",(0,s.jsx)(n.strong,{children:"recreate"})," policy, all PVCs related to it will be deleted together."]}),"\n",(0,s.jsxs)(n.li,{children:["When a Pod is updated using ",(0,s.jsx)(n.strong,{children:"in-place"})," policy, all PVCs related to it are preserved."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The following shows a sample CloneSet yaml file which contains PVC templates."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nmetadata:\n  labels:\n    app: sample\n  name: sample-data\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: sample\n  template:\n    metadata:\n      labels:\n        app: sample\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:alpine\n        volumeMounts:\n        - name: data-vol\n          mountPath: /usr/share/nginx/html\n  volumeClaimTemplates:\n    - metadata:\n        name: data-vol\n      spec:\n        accessModes: [ "ReadWriteOnce" ]\n        resources:\n          requests:\n            storage: 20Gi\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.4.0"]}),"\n",(0,s.jsxs)(n.p,{children:["When a Pod has been deleted manually, all PVCs related to the Pod are preserved, and CloneSet controller will create a new Pod with the same ",(0,s.jsx)(n.strong,{children:"instance-id"})," and reuse the PVCs."]}),"\n",(0,s.jsxs)(n.p,{children:["However, if the Node where the Pod is located experiences an exception, reusing the PVCs may result in the failure of the new Pod to start. For more details, please refer to ",(0,s.jsx)(n.a,{href:"https://github.com/openkruise/kruise/issues/1099",children:"issue 1099"}),".\nTo address this issue, you can set the ",(0,s.jsx)(n.strong,{children:"DisablePVCReuse=true"})," field, and the PVCs associated with the Pod will be automatically deleted and no longer reused."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n  ...\n  replicas: 4\n  scaleStrategy:\n    disablePVCReuse: true\n"})}),"\n",(0,s.jsx)(n.h4,{id:"when-volumeclaimtemplates-changed-always-recreate-pods-and-related-volumes",children:"When volumeClaimTemplates changed, always recreate pods and related volumes"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.7.0"]}),"\n",(0,s.jsx)(n.p,{children:"By default, if the image and volumeClaimTemplates change at the same time, CloneSet will in-place update Pod and does not rebuild the volume,\ncausing the volumeClaimTemplates configuration to not take effect."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Initially, image=nginx",":v1",", volumeClaimTemplates storage=20G"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n  template:\n  spec:\n    containers:\n    - name: nginx\n      image: nginx:v1\n      volumeMounts:\n      - name: data-vol\n        mountPath: /usr/share/nginx/html\n    volumeClaimTemplates:\n    - metadata:\n        name: data-vol\n      spec:\n        accessModes: [ "ReadWriteOnce" ]\n        resources:\n          requests:\n            storage: 20Gi\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["Change image to nginx",":v2",", and volumeClaimTemplates storage to 40G"]}),"\n",(0,s.jsx)(n.li,{children:"CloneSet in-place update Pod and does not rebuild the volume, so the volume size corresponding to the new Pod is still 20 Gi and is not up-to-date."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For the above scenario, you can turn on feature-gate ",(0,s.jsx)(n.strong,{children:"RecreatePodWhenChangeVCTInCloneSetGate=true"}),". CloneSet will rebuild the Pod and the related volume.\nAt this point, the volume of the new Pod will be 40Gi."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Note: If you only change the volumeClaimTemplates field, the Pod upgrade will not be triggered, you need to trigger the rolling upgrade by changing Labels, Annotations, Image, Env, etc."})}),"\n",(0,s.jsx)(n.h3,{id:"selective-pod-deletion",children:"Selective Pod deletion"}),"\n",(0,s.jsxs)(n.p,{children:["When a CloneSet is scaled down, sometimes user has preference to deleting specific Pods.\nThis cannot be done using ",(0,s.jsx)(n.code,{children:"StatefulSet"})," or ",(0,s.jsx)(n.code,{children:"Deployment"}),", because ",(0,s.jsx)(n.code,{children:"StatefulSet"})," always delete Pod\nin order and ",(0,s.jsx)(n.code,{children:"Deployment"}),"/",(0,s.jsx)(n.code,{children:"ReplicaSet"})," only delete Pod by its own sorted sequence."]}),"\n",(0,s.jsxs)(n.p,{children:["CloneSet allows user to specify to-be-deleted Pod names when scaling down ",(0,s.jsx)(n.code,{children:"replicas"}),". Take the following\nsample as an example,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n  # ...\n  replicas: 4\n  scaleStrategy:\n    podsToDelete:\n    - sample-9m4hp\n"})}),"\n",(0,s.jsxs)(n.p,{children:["when controller receives above update request, it ensures the number of replicas to be 4. If some Pods needs to be\ndeleted, the Pods listed in ",(0,s.jsx)(n.code,{children:"podsToDelete"})," will be deleted first.\nController will clear ",(0,s.jsx)(n.code,{children:"podsToDelete"})," automatically once the listed Pods are deleted. Note that:"]}),"\n",(0,s.jsxs)(n.p,{children:["If one just adds a Pod name to ",(0,s.jsx)(n.code,{children:"podsToDelete"})," and do not modify ",(0,s.jsx)(n.code,{children:"replicas"}),", controller will delete this Pod, and create a new Pod.\nIf one is unable to change CloneSet directly, an alternative way is to add a label ",(0,s.jsx)(n.code,{children:"apps.kruise.io/specified-delete: true"})," onto the Pod waiting to delete."]}),"\n",(0,s.jsxs)(n.p,{children:["Comparing to delete the Pod directly, using ",(0,s.jsx)(n.code,{children:"podsToDelete"})," or ",(0,s.jsx)(n.code,{children:"apps.kruise.io/specified-delete: true"}),"\nwill have CloneSet protection by ",(0,s.jsx)(n.code,{children:"maxUnavailable"}),"/",(0,s.jsx)(n.code,{children:"maxSurge"})," and lifecycle ",(0,s.jsx)(n.code,{children:"PreparingDelete"})," triggering (See below)."]}),"\n",(0,s.jsx)(n.h3,{id:"deletion-sequence",children:"Deletion Sequence"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Node unassigned < assigned"}),"\n",(0,s.jsx)(n.li,{children:"PodPending < PodUnknown < PodRunning"}),"\n",(0,s.jsx)(n.li,{children:"Not ready < ready"}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#pod-deletion-cost",children:"Lower pod-deletion cost < higher pod-deletion-cost"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#deletion-by-spread-constraints",children:"Higher spread rank < lower spread rank"})}),"\n",(0,s.jsx)(n.li,{children:"Been ready for empty time < less time < more time"}),"\n",(0,s.jsx)(n.li,{children:"Pods with containers with higher restart counts < lower restart counts"}),"\n",(0,s.jsx)(n.li,{children:"Empty creation time pods < newer pods < older pods"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"pod-deletion-cost",children:"Pod deletion cost"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v0.9.0"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/#pod-deletion-cost",children:"controller.kubernetes.io/pod-deletion-cost"})," annotation\nis defined in Kubernetes since ",(0,s.jsx)(n.code,{children:"v1.21"}),", Deployment/ReplicaSet will remove pods according to this cost when downscaling.\nAnd CloneSet has also supported it since Kruise ",(0,s.jsx)(n.code,{children:"v0.9.0"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The annotation should be set on the pod, the range is [-2147483647, 2147483647].\nIt represents the cost of deleting a pod compared to other pods belonging to the same CloneSet.\nPods with lower deletion cost are preferred to be deleted before pods with higher deletion cost."}),"\n",(0,s.jsx)(n.p,{children:"The implicit value for this annotation for pods that don't set it is 0; negative values are permitted."}),"\n",(0,s.jsx)(n.h4,{id:"deletion-by-spread-constraints",children:"Deletion by Spread Constraints"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v0.10.0"]}),"\n",(0,s.jsxs)(n.p,{children:["The original proposal(design doc) is ",(0,s.jsx)(n.a,{href:"https://github.com/openkruise/kruise/blob/master/docs/proposals/20210624-cloneset-scaledown-topology-spread.md",children:"here"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Currently, it supports ",(0,s.jsx)(n.strong,{children:"deletion by same node spread"})," and ",(0,s.jsxs)(n.strong,{children:["deletion by ",(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/",children:"pod topolocy spread constraints"})]}),"."]}),"\n",(0,s.jsx)(n.p,{children:"If there are Pod Topology Spread Constraints defined in CloneSet template, controller will choose pods according to spread constraints when the cloneset needs to scale down.\nOtherwise, controller will choose pods by same node spread by default when scaling down."}),"\n",(0,s.jsx)(n.h3,{id:"short-hash-label",children:"Short hash label"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v0.9.0"]}),"\n",(0,s.jsxs)(n.p,{children:["By default, CloneSet set the ",(0,s.jsx)(n.code,{children:"controller-revision-hash"})," in Pod label to the full name of ControllerRevision, such as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    controller-revision-hash: demo-cloneset-956df7994\n"})}),"\n",(0,s.jsx)(n.p,{children:"It is joined by the name of CloneSet and the hash of the ControllerRevision.\nLength of the hash is usually 8~10 characters, and the label value in Kubernetes can not be more than 63 characters.\nSo the name of CloneSet should be less than 52 characters."}),"\n",(0,s.jsxs)(n.p,{children:["A new feature-gate named ",(0,s.jsx)(n.code,{children:"CloneSetShortHash"})," has been introduced.\nIf it is enabled, CloneSet will only set the ",(0,s.jsx)(n.code,{children:"controller-revision-hash"})," to the real hash, such as ",(0,s.jsx)(n.code,{children:"956df7994"}),".\nSo there will be no limit to CloneSet name."]}),"\n",(0,s.jsxs)(n.p,{children:["Don't worry. Even if you enable the ",(0,s.jsx)(n.code,{children:"CloneSetShortHash"}),", CloneSet will still recognize and manage the old Pods with full revision label."]}),"\n",(0,s.jsxs)(n.p,{children:["Since Kruise v1.1.0, CloneSet will add another ",(0,s.jsx)(n.code,{children:"pod-template-hash"})," label into Pods, which will always be the short hash."]}),"\n",(0,s.jsx)(n.h3,{id:"scale-up-with-rate-limit",children:"Scale up with rate limit"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.0.0"]}),"\n",(0,s.jsxs)(n.p,{children:["Users can specify ",(0,s.jsx)(n.code,{children:"ScaleStrategy.MaxUnavailable"})," to limit the step size of CloneSet ",(0,s.jsx)(n.strong,{children:"Scaling Up"}),", so as to minimize the impact on application services.\nThis value can be an ",(0,s.jsx)(n.strong,{children:"absolute number"})," (e.g., 5) or a ",(0,s.jsx)(n.strong,{children:"percentage"})," of desired number of Pods (e.g., 10%). Default value is ",(0,s.jsx)(n.code,{children:"nil"})," (i.e., empty pointer), which indicates non-limitation."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ScaleStrategy.MaxUnavailable"})," field can cooperate with 'Spec.MinReadySeconds' field to work, for example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n  # ...\n  minReadySeconds: 60\n  scaleStrategy:\n    maxUnavailable: 1\n"})}),"\n",(0,s.jsx)(n.p,{children:"The effect of the above configuration is that during scaling up, CloneSet will not create the next pod until the previous pod has been ready for more than one minute."}),"\n",(0,s.jsx)(n.h2,{id:"update-features",children:"Update features"}),"\n",(0,s.jsx)(n.h3,{id:"update-types",children:"Update types"}),"\n",(0,s.jsxs)(n.p,{children:["CloneSet provides three update types, defaults to ",(0,s.jsx)(n.code,{children:"ReCreate"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ReCreate"}),": controller will delete old Pods and PVCs and create new ones."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"InPlaceIfPossible"}),": controller will try to in-place update Pod instead of recreating them if possible. Current only image and other fields are supported for in-place update."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"InPlaceOnly"}),": controller will in-place update Pod instead of recreating them. With ",(0,s.jsx)(n.code,{children:"InPlaceOnly"})," policy, user cannot modify any fields other than the fields that supported to in-place update."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["You may need to read the ",(0,s.jsx)(n.a,{href:"../core-concepts/inplace-update",children:"concept doc"})," for more details of in-place update."]})}),"\n",(0,s.jsxs)(n.p,{children:["We also bring ",(0,s.jsx)(n.strong,{children:"graceful period"})," into in-place update. CloneSet has supported ",(0,s.jsx)(n.code,{children:"gracePeriodSeconds"}),", which is a period\nduration between controller update pod status and update pod images.\nSo that endpoints-controller could have enough time to remove this Pod from endpoints."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n  # ...\n  updateStrategy:\n    type: InPlaceIfPossible\n    inPlaceUpdateStrategy:\n      gracePeriodSeconds: 10\n"})}),"\n",(0,s.jsx)(n.h3,{id:"template-and-revision",children:"Template and revision"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"spec.template"})," defines the latest pod template in the CloneSet.\nController will calculate a revision hash for each version of ",(0,s.jsx)(n.code,{children:"spec.template"})," when it has been initialized or modified.\nFor example, when we create a sample CloneSet, controller will calculate the revision hash ",(0,s.jsx)(n.code,{children:"sample-744d4796cc"})," and\npresent the hash in CloneSet Status."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nmetadata:\n  generation: 1\n  # ...\nspec:\n  replicas: 5\n  # ...\nstatus:\n  observedGeneration: 1\n  readyReplicas: 5\n  replicas: 5\n  currentRevision: sample-d4d4fb5bd\n  updateRevision: sample-d4d4fb5bd\n  updatedReadyReplicas: 5\n  updatedReplicas: 5\n  # ...\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here are the explanations for the counters presented in CloneSet status:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"status.replicas"}),": Number of pods"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"status.readyReplicas"}),": Number of ",(0,s.jsx)(n.strong,{children:"ready"})," pods"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"status.availableReplicas"}),": Number of ",(0,s.jsx)(n.strong,{children:"ready and available"})," pods (satisfied with ",(0,s.jsx)(n.code,{children:"minReadySeconds"})," and pod lifecycle state is ",(0,s.jsx)(n.code,{children:"Normal"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"status.currentRevision"}),": Latest revision hash that has used to be updated to all Pods"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"status.updateRevision"}),": Latest revision hash of this CloneSet"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"status.updatedReplicas"}),": Number of pods with the latest revision"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"status.updatedReadyReplicas"}),": Number of ",(0,s.jsx)(n.strong,{children:"ready"})," pods with the latest revision"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.2.0"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"status.expectedUpdatedReplicas"}),": Number of the pods that were updated or will be updated with the latest revision under the current ",(0,s.jsx)(n.code,{children:"partition"})," settings."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"partition",children:"Partition"}),"\n",(0,s.jsxs)(n.p,{children:["Partition is the ",(0,s.jsx)(n.strong,{children:"desired number or percent of Pods in old revisions"}),", defaults to ",(0,s.jsx)(n.code,{children:"0"}),".  This field does ",(0,s.jsx)(n.strong,{children:"NOT"})," imply any update order."]}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"partition"})," is set during update:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If it is a number: ",(0,s.jsx)(n.code,{children:"(replicas - partition)"})," number of pods will be updated with the new version."]}),"\n",(0,s.jsxs)(n.li,{children:["If it is a percent: ",(0,s.jsx)(n.code,{children:"(replicas * (100% - partition))"})," number of pods will be updated with the new version."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.2.0"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"partition"})," is a percent, and ",(0,s.jsx)(n.code,{children:"partition < 100% && replicas > 1"})," , CloneSet will ensure ",(0,s.jsx)(n.strong,{children:"at least one pod"})," will be updated with the new version."]}),"\n",(0,s.jsxs)(n.li,{children:["One can use the condition ",(0,s.jsx)(n.code,{children:".status.updatedReplicas >= .status.expectedUpdatedReplicas"})," to decide whether workload had finish rolling out new revision under partition restriction."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For example, when we update sample CloneSet's container image to ",(0,s.jsx)(n.code,{children:"nginx:mainline"})," and set ",(0,s.jsx)(n.code,{children:"partition=3"}),", after a while, the sample CloneSet yaml looks like the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nmetadata:\n  # ...\n  generation: 2\nspec:\n  replicas: 5\n  template:\n    metadata:\n      labels:\n        app: sample\n    spec:\n      containers:\n      - image: nginx:mainline\n        imagePullPolicy: Always\n        name: nginx\n  updateStrategy:\n    partition: 3\n  # ...\nstatus:\n  observedGeneration: 2\n  readyReplicas: 5\n  replicas: 5\n  currentRevision: sample-d4d4fb5bd\n  updateRevision: sample-56dfb978d4\n  updatedReadyReplicas: 2\n  updatedReplicas: 2\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that ",(0,s.jsx)(n.code,{children:"status.updateRevision"})," has been updated to ",(0,s.jsx)(n.code,{children:"sample-56dfb978d4"}),", a new hash.\nSince we set ",(0,s.jsx)(n.code,{children:"partition=3"}),", controller only updates two Pods to the latest revision."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ kubectl get pod -L controller-revision-hash\nNAME           READY   STATUS    RESTARTS   AGE     CONTROLLER-REVISION-HASH\nsample-chvnr   1/1     Running   0          6m46s   sample-d4d4fb5bd\nsample-j6c4s   1/1     Running   0          6m46s   sample-d4d4fb5bd\nsample-ns85c   1/1     Running   0          6m46s   sample-d4d4fb5bd\nsample-jnjdp   1/1     Running   0          10s     sample-56dfb978d4\nsample-qqglp   1/1     Running   0          18s     sample-56dfb978d4\n"})}),"\n",(0,s.jsx)(n.h4,{id:"rollback-by-partition",children:"Rollback by partition"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v0.9.0"]}),"\n",(0,s.jsxs)(n.p,{children:["By default, ",(0,s.jsx)(n.code,{children:"partition"})," can only control Pods updating to the ",(0,s.jsx)(n.code,{children:"status.updateRevision"}),".\nWhich means for this CloneSet, when changes ",(0,s.jsx)(n.code,{children:"partition 5 -> 3"}),", CloneSet will update 2 Pods to ",(0,s.jsx)(n.code,{children:"status.updateRevision"}),".\nThen changes ",(0,s.jsx)(n.code,{children:"partition 3 -> 5"})," back, CloneSet will do nothing."]}),"\n",(0,s.jsxs)(n.p,{children:["But if you have enabled ",(0,s.jsx)(n.code,{children:"CloneSetPartitionRollback"})," feature-gate, in this case,\nCloneSet will update the 2 Pods in ",(0,s.jsx)(n.code,{children:"status.updateRevision"})," back to ",(0,s.jsx)(n.code,{children:"status.currentRevision"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"maxunavailable",children:"MaxUnavailable"}),"\n",(0,s.jsxs)(n.p,{children:["MaxUnavailable is the maximum number of Pods that can be unavailable.\nValue can be an ",(0,s.jsx)(n.strong,{children:"absolute number"})," (e.g., 5) or a ",(0,s.jsx)(n.strong,{children:"percentage"})," of desired number of Pods (e.g., 10%).\nDefault value is 20%."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n  # ...\n  updateStrategy:\n    maxUnavailable: 20%\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since Kruise ",(0,s.jsx)(n.code,{children:"v0.9.0"}),", ",(0,s.jsx)(n.code,{children:"maxUnavailable"})," not only controls Pods update, but also affect Pods specified deletion."]}),"\n",(0,s.jsxs)(n.p,{children:["Which means if you declare to delete a Pod via ",(0,s.jsx)(n.code,{children:"podsToDelete"})," or ",(0,s.jsx)(n.code,{children:"apps.kruise.io/specified-delete: true"}),",\nCloneSet will delete it only if the number of unavailable Pods (comparing to the replicas number) is less than ",(0,s.jsx)(n.code,{children:"maxUnavailable"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"maxsurge",children:"MaxSurge"}),"\n",(0,s.jsxs)(n.p,{children:["MaxSurge is the maximum number of pods that can be scheduled above the desired replicas.\nValue can be an ",(0,s.jsx)(n.strong,{children:"absolute number"})," (ex: 5) or a ",(0,s.jsx)(n.strong,{children:"percentage"})," of desired pods (ex: 10%).\nDefaults to 0."]}),"\n",(0,s.jsxs)(n.p,{children:["If maxSurge is set somewhere, cloneset-controller will create ",(0,s.jsx)(n.code,{children:"maxSurge"})," number of Pods above the ",(0,s.jsx)(n.code,{children:"replicas"}),",\nwhen it finds multiple active revisions of Pods which means the CloneSet is in the update stage.\nAfter all Pods except ",(0,s.jsx)(n.code,{children:"partition"})," number have been updated to the latest revision, ",(0,s.jsx)(n.code,{children:"maxSurge"})," number Pods will be deleted,\nand the number of Pods will be equal to the ",(0,s.jsx)(n.code,{children:"replica"})," number."]}),"\n",(0,s.jsxs)(n.p,{children:["What's more, maxSurge is forbidden to use with ",(0,s.jsx)(n.code,{children:"InPlaceOnly"})," policy.\nWhen maxSurge is used with ",(0,s.jsx)(n.code,{children:"InPlaceIfPossible"}),", controller will create additional Pods with latest revision first,\nand then update the rest Pods with old revisions,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n  # ...\n  updateStrategy:\n    maxSurge: 3\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since Kruise ",(0,s.jsx)(n.code,{children:"v0.9.0"}),", ",(0,s.jsx)(n.code,{children:"maxSurge"})," not only controls Pods update, but also affect Pods specified deletion."]}),"\n",(0,s.jsxs)(n.p,{children:["Which means if you declare to delete a Pod via ",(0,s.jsx)(n.code,{children:"podsToDelete"})," or ",(0,s.jsx)(n.code,{children:"apps.kruise.io/specified-delete: true"}),",\nCloneSet may create new a Pod, wait it to be ready, and them delete the old one.\nIt depends on ",(0,s.jsx)(n.code,{children:"maxUnavailable"})," and the current number of unavailable Pods."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For a CloneSet ",(0,s.jsx)(n.code,{children:"maxUnavailable=2, maxSurge=1"})," and currently only one unavailable Pods is ",(0,s.jsx)(n.code,{children:"pod-a"}),",\nif you patch ",(0,s.jsx)(n.code,{children:"apps.kruise.io/specified-delete: true"})," onto ",(0,s.jsx)(n.code,{children:"pod-b"})," or put the Pod name into ",(0,s.jsx)(n.code,{children:"podsToDelete"}),",\nCloneSet will delete it directly."]}),"\n",(0,s.jsxs)(n.li,{children:["For a CloneSet ",(0,s.jsx)(n.code,{children:"maxUnavailable=1, maxSurge=1"})," and currently only one unavailable Pods is ",(0,s.jsx)(n.code,{children:"pod-a"}),",\nif you patch ",(0,s.jsx)(n.code,{children:"apps.kruise.io/specified-delete: true"})," onto ",(0,s.jsx)(n.code,{children:"pod-b"})," or put the Pod name into ",(0,s.jsx)(n.code,{children:"podsToDelete"}),",\nCloneSet will create a new Pod, waiting it to be ready, and finally delete ",(0,s.jsx)(n.code,{children:"pod-b"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["For a CloneSet ",(0,s.jsx)(n.code,{children:"maxUnavailable=1, maxSurge=1"})," and currently only one unavailable Pods is ",(0,s.jsx)(n.code,{children:"pod-a"}),",\nif you patch ",(0,s.jsx)(n.code,{children:"apps.kruise.io/specified-delete: true"})," onto ",(0,s.jsx)(n.code,{children:"pod-a"})," or put the Pod name into ",(0,s.jsx)(n.code,{children:"podsToDelete"}),",\nCloneSet will delete it directly."]}),"\n",(0,s.jsx)(n.li,{children:"..."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"update-sequence",children:"Update sequence"}),"\n",(0,s.jsxs)(n.p,{children:["When controller chooses Pods to update, it has default sort logic based on Pod phase and conditions:\n",(0,s.jsx)(n.strong,{children:"unscheduled < scheduled, pending < unknown < running, not-ready < ready"}),".\nIn addition, CloneSet also supports advanced ",(0,s.jsx)(n.code,{children:"priority"})," and ",(0,s.jsx)(n.code,{children:"scatter"})," strategies to allow users to specify the update order."]}),"\n",(0,s.jsx)(n.h4,{id:"priority",children:"priority"}),"\n",(0,s.jsxs)(n.p,{children:["This strategy defines rules for calculating the priority of updating pods.\nAll update candidates will be applied with the priority terms.\n",(0,s.jsx)(n.code,{children:"priority"})," can be calculated either by weight or by order."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"weight"}),": Priority is determined by the sum of weights for terms that match selector. For example,"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n  # ...\n  updateStrategy:\n    priorityStrategy:\n      weightPriority:\n      - weight: 50\n        matchSelector:\n          matchLabels:\n            test-key: foo\n      - weight: 30\n        matchSelector:\n          matchLabels:\n            test-key: bar\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"order"}),': Priority will be determined by the value of the orderKey. The update candidates are sorted based on the "int" part of the value string. For example, 5 in string "5" and 10 in string "sts-10".']}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n  # ...\n  updateStrategy:\n    priorityStrategy:\n      orderPriority:\n        - orderedKey: some-label-key\n"})}),"\n",(0,s.jsx)(n.h4,{id:"scatter",children:"scatter"}),"\n",(0,s.jsxs)(n.p,{children:["This strategy defines rules to make certain Pods be scattered during update.\nFor example, if a CloneSet has ",(0,s.jsx)(n.code,{children:"replica=10"}),", and we add ",(0,s.jsx)(n.code,{children:"foo=bar"})," label in 3 Pods and specify the following scatter rule. These 3 Pods will\nbe the 1st, 6th and 10th updated Pods."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n  # ...\n  updateStrategy:\n    scatterStrategy:\n    - key: foo\n      value: bar\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note that:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Although ",(0,s.jsx)(n.code,{children:"priority"})," strategy and ",(0,s.jsx)(n.code,{children:"scatter"})," strategy can be applied together, we strongly suggest to just use one of them to avoid confusion."]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"scatter"})," strategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Last but not the least, the above advanced update strategies require independent Pod labeling mechanisms, which are not provided by CloneSet."}),"\n",(0,s.jsx)(n.h3,{id:"paused-update",children:"Paused update"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"paused"})," indicates that Pods updating is paused, controller will not update Pods but just maintain the number of replicas."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n  # ...\n  updateStrategy:\n    paused: true\n"})}),"\n",(0,s.jsx)(n.h3,{id:"in-place-update-support-for-modifying-resources",children:"In-Place Update Support for Modifying Resources"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.8.0"]}),"\n",(0,s.jsxs)(n.p,{children:["If you have enabled ",(0,s.jsx)(n.code,{children:"InPlaceWorkloadVerticalScaling"})," during ",(0,s.jsx)(n.a,{href:"../installation##optional-feature-gate",children:"Kruise installation or upgrade"}),",\nCloneSet supports modifying container resources (CPU/Memory) during in-place updates.\nThis feature allows users to directly update the following fields without triggering Pod recreation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n  #...\n  template:\n    spec:\n      containers:\n      - name: <container-name>\n        resources:\n          requests:\n            cpu: "2"       # Can be modified\n            memory: "2Gi"  # Can be modified\n          limits:\n            cpu: "4"       # Can be modified\n            memory: "4Gi"  # Can be modified\n'})}),"\n",(0,s.jsx)(n.h4,{id:"notes",children:"Notes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["This feature requires the Kubernetes cluster to have the ",(0,s.jsx)(n.code,{children:"InPlacePodVerticalScaling"})," feature-gate enabled. Ensure your cluster supports this capability. For more information, refer to the ",(0,s.jsx)(n.a,{href:"https://kubernetes.io/zh-cn/blog/2023/05/12/in-place-pod-resize-alpha/",children:"Kubernetes documentation"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cgroupv1 Limitations"}),":"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In a Cgroupv1 environment, ",(0,s.jsx)(n.strong,{children:"modifying both image and resource fields simultaneously is prohibited"})," (e.g., updating both the image and CPU quota at the same time). The operation must be performed in two steps:","\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"First, complete the in-place update for resource modifications."}),"\n",(0,s.jsx)(n.li,{children:"Then, trigger an in-place update for image changes."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["For more details, see the community ",(0,s.jsx)(n.a,{href:"https://github.com/kubernetes/kubernetes/issues/127356",children:"Issue #127356"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Type Restrictions"}),":"]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Only modifications to ",(0,s.jsx)(n.code,{children:"cpu"})," and ",(0,s.jsx)(n.code,{children:"memory"})," fields within ",(0,s.jsx)(n.code,{children:"requests"})," and ",(0,s.jsx)(n.code,{children:"limits"})," are supported."]}),"\n",(0,s.jsx)(n.li,{children:"Other resource types (e.g., GPU) will trigger Pod recreation."}),"\n",(0,s.jsx)(n.li,{children:"Modifications to resources must not alter the Pod's QoS. If the Pod's QoS changes, it will trigger Pod recreation."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"pre-download-image-for-in-place-update",children:"Pre-download image for in-place update"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v0.9.0"]}),"\n",(0,s.jsxs)(n.p,{children:["If you have enabled the ",(0,s.jsx)(n.code,{children:"PreDownloadImageForInPlaceUpdate"})," feature-gate during ",(0,s.jsx)(n.a,{href:"../installation#optional-feature-gate",children:"Kruise installation or upgrade"}),",\nCloneSet controller will automatically pre-download the image you want to update to the nodes of all old Pods.\nIt is quite useful to accelerate the progress of applications upgrade."]}),"\n",(0,s.jsxs)(n.p,{children:["The parallelism of each new image pre-downloading by CloneSet is ",(0,s.jsx)(n.code,{children:"1"}),", which means the image is downloaded on nodes one by one.\nYou can change the parallelism using ",(0,s.jsx)(n.code,{children:"apps.kruise.io/image-predownload-parallelism"})," annotation on CloneSet according to the capability of image registry,\nfor registries with more bandwidth and P2P image downloading ability, a larger parallelism can speed up the pre-download process."]}),"\n",(0,s.jsxs)(n.p,{children:["Since Kruise v1.1.0, you can use ",(0,s.jsx)(n.code,{children:"apps.kruise.io/image-predownload-min-updated-ready-pods"})," to make sure the new image starting pre-download after a few new Pods have been updated ready. Its value can be absolute number or percentage."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nmetadata:\n  annotations:\n    apps.kruise.io/image-predownload-parallelism: "10"\n    apps.kruise.io/image-predownload-min-updated-ready-pods: "3"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note that to avoid most unnecessary image downloading, now controller will only pre-download images for CloneSet with replicas > ",(0,s.jsx)(n.code,{children:"3"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"lifecycle-hook",children:"Lifecycle hook"}),"\n",(0,s.jsxs)(n.p,{children:["Each Pod managed by CloneSet has a clear state defined in ",(0,s.jsx)(n.code,{children:"lifecycle.apps.kruise.io/state"})," label:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Normal"}),"\n",(0,s.jsx)(n.li,{children:"PreparingUpdate"}),"\n",(0,s.jsx)(n.li,{children:"Updating"}),"\n",(0,s.jsx)(n.li,{children:"Updated"}),"\n",(0,s.jsx)(n.li,{children:"PreparingDelete"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Lifecycle hook allows users to do something (for example remove pod from service endpoints) during Pod deleting and before/after in-place update."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'type LifecycleStateType string\n\n// Lifecycle contains the hooks for Pod lifecycle.\ntype Lifecycle struct\n    // PreDelete is the hook before Pod to be deleted.\n    PreDelete *LifecycleHook `json:"preDelete,omitempty"`\n    // InPlaceUpdate is the hook before Pod to update and after Pod has been updated.\n    InPlaceUpdate *LifecycleHook `json:"inPlaceUpdate,omitempty"`\n    // PreNormal is the hook after Pod to be created and ready to be Normal.\n    PreNormal *LifecycleHook `json:"preNormal,omitempty"`\n}\n\ntype LifecycleHook struct {\n    LabelsHandler     map[string]string `json:"labelsHandler,omitempty"`\n    FinalizersHandler []string          `json:"finalizersHandler,omitempty"`\n\n    /**********************  FEATURE STATE: 1.2.0 ************************/\n    // MarkPodNotReady = true means:\n    // - Pod will be set to \'NotReady\' at preparingDelete/preparingUpdate state.\n    // - Pod will be restored to \'Ready\' at Updated state if it was set to \'NotReady\' at preparingUpdate state.\n    // Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook.\n    // Default to false.\n    MarkPodNotReady bool `json:"markPodNotReady,omitempty"`\n    /*********************************************************************/\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Examples:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n\n  # define with finalizer\n  lifecycle:\n    preNormal:\n      finalizersHandler:\n      - example.io/unready-blocker\n    preDelete:\n      finalizersHandler:\n      - example.io/unready-blocker\n    inPlaceUpdate:\n      finalizersHandler:\n      - example.io/unready-blocker\n\n  # or define with label\n  # lifecycle:\n  #   inPlaceUpdate:\n  #     labelsHandler:\n  #       example.io/block-unready: "true"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"markpodnotready",children:"MarkPodNotReady"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.2.0"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"  lifecycle:\n    preDelete:\n      markPodNotReady: true\n      finalizersHandler:\n      - example.io/unready-blocker\n    inPlaceUpdate:\n      markPodNotReady: true\n      finalizersHandler:\n      - example.io/unready-blocker\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you set ",(0,s.jsx)(n.code,{children:"markPodNotReady=true"})," for ",(0,s.jsx)(n.code,{children:"preDelete"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Kruise will try to set ",(0,s.jsx)(n.code,{children:"KruisePodReady"})," condition to ",(0,s.jsx)(n.code,{children:"False"})," when Pods enter ",(0,s.jsx)(n.code,{children:"PreparingDelete"})," lifecycle state, and Pods will be set to ",(0,s.jsx)(n.strong,{children:"NotReady"}),", but containers still ",(0,s.jsx)(n.code,{children:"Running"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["If you set ",(0,s.jsx)(n.code,{children:"markPodNotReady=true"})," for ",(0,s.jsx)(n.code,{children:"inPlaceUpdate"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Kruise will try to set ",(0,s.jsx)(n.code,{children:"KruisePodReady"})," condition to ",(0,s.jsx)(n.code,{children:"False"})," when Pods enter ",(0,s.jsx)(n.code,{children:"PreparingUpdate"})," lifecycle state, and Pods will be set to ",(0,s.jsx)(n.strong,{children:"NotReady"}),", but containers still ",(0,s.jsx)(n.code,{children:"Running"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Kruise will try to set ",(0,s.jsx)(n.code,{children:"KruisePodReady"})," condition to ",(0,s.jsx)(n.code,{children:"True"})," when Pods enter ",(0,s.jsx)(n.code,{children:"Updated"})," lifecycle state."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["One can use this ",(0,s.jsx)(n.code,{children:"markPodNotReady"})," feature to drain service traffic before terminating containers."]})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Note: this feature only works when pod has ",(0,s.jsx)(n.code,{children:"KruisePodReady"})," ReadinessGate."]})}),"\n",(0,s.jsx)(n.h3,{id:"state-circulation",children:"State circulation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Lifecycle circulation",src:i(86301).A+"",width:"1546",height:"876"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["When CloneSet create a Pod (including scaling up and recreate update):","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The Pod will be regarded as ",(0,s.jsx)(n.code,{children:"Available"})," only after PreNormal hook is satisfied."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"PreNormal"})," hook can be used for post-checks after pod creation. For example, one can check if the pod have been added as the SLB backends successfully. Without preNormal hook, one may encounter traffic loss during rolling upgrades if Operator(e.g., CCM) fails to add new pods to the SLB backends."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["When CloneSet delete a Pod (including scale in and recreate update):","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Delete it directly if no lifecycle hook definition or Pod not matched preDelete hook"}),"\n",(0,s.jsxs)(n.li,{children:["Otherwise, CloneSet will firstly update Pod to ",(0,s.jsx)(n.code,{children:"PreparingDelete"})," state and wait for user controller to remove the label/finalizer and Pod not matched preDelete hook"]}),"\n",(0,s.jsxs)(n.li,{children:["Note that Pods in ",(0,s.jsx)(n.code,{children:"PreparingDelete"})," state will not be updated"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["When CloneSet update a Pod in-place:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If lifecycle hook defined and Pod matched inPlaceUpdate hook, CloneSet will update Pod to ",(0,s.jsx)(n.code,{children:"PreparingUpdate"})," state"]}),"\n",(0,s.jsxs)(n.li,{children:["After user controller remove the label/finalizer (thus Pod not matched inPlaceUpdate hook), CloneSet will update it to ",(0,s.jsx)(n.code,{children:"Updating"})," state and start updating"]}),"\n",(0,s.jsxs)(n.li,{children:["After in-place update completed, CloneSet will update Pod to ",(0,s.jsx)(n.code,{children:"Updated"})," state if lifecycle hook defined and Pod not matched inPlaceUpdate hook"]}),"\n",(0,s.jsxs)(n.li,{children:["When user controller add label/finalizer into Pod and it matched inPlaceUpdate hook, CloneSet will finally update it to ",(0,s.jsx)(n.code,{children:"Normal"})," state"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Besides, although our design supports to change a Pod from ",(0,s.jsx)(n.code,{children:"PreparingDelete"})," back to ",(0,s.jsx)(n.code,{children:"Normal"})," (through cancel specified delete), but it is not recommended. Because Pods in ",(0,s.jsx)(n.code,{children:"PreparingDelete"})," state will not be updated by CloneSet, it might be updating immediately if comes back to ",(0,s.jsx)(n.code,{children:"Normal"}),". This case is hard for user controller to handle."]}),"\n",(0,s.jsx)(n.h3,{id:"example-for-user-controller-logic",children:"Example for user controller logic"}),"\n",(0,s.jsx)(n.p,{children:"Same as yaml example above, we can firstly define\uff1a"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"example.io/unready-blocker"})," finalizer as hook"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Add these fields into CloneSet template:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: CloneSet\nspec:\n  lifecycle:\n    preNormal:\n      finalizersHandler:\n      - example.io/unready-blocker\n    preDelete:\n      finalizersHandler:\n      - example.io/unready-blocker\n    inPlaceUpdate:\n      finalizersHandler:\n      - example.io/unready-blocker\n  template:\n  # ...\n"})}),"\n",(0,s.jsx)(n.p,{children:"User controller logic:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For Pod in ",(0,s.jsx)(n.code,{children:"PreparingNormal"})," state, if there is no ",(0,s.jsx)(n.code,{children:"example.io/unready-blocker"}),", patch the finalizer to Pod, and Pod will be available for CloneSet, and will enter ",(0,s.jsx)(n.code,{children:"Normal"})," state."]}),"\n",(0,s.jsxs)(n.li,{children:["For Pod in ",(0,s.jsx)(n.code,{children:"PreparingDelete"})," and ",(0,s.jsx)(n.code,{children:"PreparingUpdate"})," states, delete it from endpoints and remove ",(0,s.jsx)(n.code,{children:"example.io/unready-blocker"})," finalizer"]}),"\n",(0,s.jsxs)(n.li,{children:["For Pod in ",(0,s.jsx)(n.code,{children:"Updated"})," state, add it to endpoints and add ",(0,s.jsx)(n.code,{children:"example.io/unready-blocker"})," finalizer"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"scaling-with-preparingdelete",children:"Scaling with PreparingDelete"}),"\n",(0,s.jsx)(n.p,{children:"FEATURE STATE: Kruise v1.3.0"}),"\n",(0,s.jsxs)(n.p,{children:["CloneSet considers Pods in ",(0,s.jsx)(n.code,{children:"PreparingDelete"})," state as normal by default, which means these Pods will still be calculated in the ",(0,s.jsx)(n.code,{children:"replicas"})," number."]}),"\n",(0,s.jsx)(n.p,{children:"In this situation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["if you scale down ",(0,s.jsx)(n.code,{children:"replicas"})," from ",(0,s.jsx)(n.code,{children:"N"})," to ",(0,s.jsx)(n.code,{children:"N-1"}),", when the Pod to be deleted is still in ",(0,s.jsx)(n.code,{children:"PreparingDelete"}),", you scale up ",(0,s.jsx)(n.code,{children:"replicas"})," to ",(0,s.jsx)(n.code,{children:"N"}),", the CloneSet will move the Pod back to ",(0,s.jsx)(n.code,{children:"Normal"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["if you scale down ",(0,s.jsx)(n.code,{children:"replicas"})," from ",(0,s.jsx)(n.code,{children:"N"})," to ",(0,s.jsx)(n.code,{children:"N-1"})," and put a Pod into ",(0,s.jsx)(n.code,{children:"podsToDelete"}),", when the specific Pod is still in ",(0,s.jsx)(n.code,{children:"PreparingDelete"}),", you scale up ",(0,s.jsx)(n.code,{children:"replicas"})," to ",(0,s.jsx)(n.code,{children:"N"}),", the CloneSet will not create a new Pod until the specific Pod goes into terminating."]}),"\n",(0,s.jsxs)(n.li,{children:["if you specifically delete a Pod without ",(0,s.jsx)(n.code,{children:"replicas"})," changed, when the specific Pod is still in ",(0,s.jsx)(n.code,{children:"PreparingDelete"}),", the CloneSet will not create a new Pod until the specific Pod goes into terminating."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Since Kruise v1.3.0, you can put a ",(0,s.jsx)(n.code,{children:'apps.kruise.io/cloneset-scaling-exclude-preparing-delete: "true"'})," label into CloneSet, which indicates Pods in ",(0,s.jsx)(n.code,{children:"PreparingDelete"})," will not be calculated in the ",(0,s.jsx)(n.code,{children:"replicas"})," number."]}),"\n",(0,s.jsx)(n.p,{children:"In this situation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["if you scale down ",(0,s.jsx)(n.code,{children:"replicas"})," from ",(0,s.jsx)(n.code,{children:"N"})," to ",(0,s.jsx)(n.code,{children:"N-1"}),", when the Pod to be deleted is still in ",(0,s.jsx)(n.code,{children:"PreparingDelete"}),", you scale up ",(0,s.jsx)(n.code,{children:"replicas"})," to ",(0,s.jsx)(n.code,{children:"N"}),", the CloneSet will move the Pod back to ",(0,s.jsx)(n.code,{children:"Normal"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["if you scale down ",(0,s.jsx)(n.code,{children:"replicas"})," from ",(0,s.jsx)(n.code,{children:"N"})," to ",(0,s.jsx)(n.code,{children:"N-1"})," and put a Pod into ",(0,s.jsx)(n.code,{children:"podsToDelete"}),", even if the specific Pod is still in ",(0,s.jsx)(n.code,{children:"PreparingDelete"}),", you scale up ",(0,s.jsx)(n.code,{children:"replicas"})," to ",(0,s.jsx)(n.code,{children:"N"}),", the CloneSet will create a new Pod immediately."]}),"\n",(0,s.jsxs)(n.li,{children:["if you specifically delete a Pod without ",(0,s.jsx)(n.code,{children:"replicas"})," changed, even if the specific Pod is still in ",(0,s.jsx)(n.code,{children:"PreparingDelete"}),", the CloneSet will create a new Pod immediately."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization",children:"Performance optimization"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.4.0"]}),"\n",(0,s.jsx)(n.p,{children:"Currently, both status and metadata changes of Pods will trigger the reconcile of CloneSet Controller. CloneSet Reconcile is configured by default with three workers, it works normally in small-scale clusters."}),"\n",(0,s.jsxs)(n.p,{children:["However, for larger clusters or scenarios with frequent Pod update events, these unnecessary reconciles will block the real CloneSet reconciles, resulting in delayed rolling updates and other changes.\nTo solve this problem, you can enable the ",(0,s.jsx)(n.strong,{children:"feature-gate CloneSetEventHandlerOptimization"})," to reduce some unnecessary reconcile enqueues."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},86301:(e,n,i)=>{i.d(n,{A:()=>l});const l=i.p+"assets/images/cloneset-lifecycle-e8bbc99ea0c5b752fdc0dc82aaf07236.png"}}]);