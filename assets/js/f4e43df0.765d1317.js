"use strict";(self.webpackChunkopenkruise_io=self.webpackChunkopenkruise_io||[]).push([[4445],{4972:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"user-manuals/broadcastjob","title":"BroadcastJob","description":"Note: v1beta1 available from Kruise v1.9.0","source":"@site/docs/user-manuals/broadcastjob.md","sourceDirName":"user-manuals","slug":"/user-manuals/broadcastjob","permalink":"/docs/next/user-manuals/broadcastjob","draft":false,"unlisted":false,"editUrl":"https://github.com/openkruise/openkruise.io/edit/master/docs/user-manuals/broadcastjob.md","tags":[],"version":"current","lastUpdatedBy":"PersistentJZH","lastUpdatedAt":1765285623000,"frontMatter":{"title":"BroadcastJob"},"sidebar":"docs","previous":{"title":"Advanced DaemonSet","permalink":"/docs/next/user-manuals/advanceddaemonset"},"next":{"title":"AdvancedCronJob","permalink":"/docs/next/user-manuals/advancedcronjob"}}');var l=a(74848),s=a(28453),i=a(65537),r=a(79329);const o={title:"BroadcastJob"},c=void 0,d={},u=[{value:"Spec definition",id:"spec-definition",level:2},{value:"Template",id:"template",level:3},{value:"Parallelism",id:"parallelism",level:3},{value:"CompletionPolicy",id:"completionpolicy",level:3},{value:"Always (default)",id:"always-default",level:4},{value:"Never",id:"never",level:4},{value:"FailurePolicy",id:"failurepolicy",level:3},{value:"Type",id:"type",level:4},{value:"RestartLimit",id:"restartlimit",level:4},{value:"Examples",id:"examples",level:2},{value:"Monitor BroadcastJob status",id:"monitor-broadcastjob-status",level:3},{value:"ttlSecondsAfterFinished",id:"ttlsecondsafterfinished",level:3},{value:"activeDeadlineSeconds",id:"activedeadlineseconds",level:3},{value:"completionPolicy",id:"completionpolicy-1",level:3},{value:"failurePolicy",id:"failurepolicy-1",level:3},{value:"restartLimit",id:"restartlimit-1",level:4}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Note: v1beta1 available from Kruise v1.9.0"})}),"\n",(0,l.jsxs)(n.p,{children:["This controller distributes a Pod on every node in the cluster.\nLike a ",(0,l.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/",children:"DaemonSet"}),",\na BroadcastJob makes sure a Pod is created and run on all selected nodes once in a cluster.\nLike a ",(0,l.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/",children:"Job"}),",\na BroadcastJob is expected to run to completion."]}),"\n",(0,l.jsx)(n.p,{children:"In the end, BroadcastJob does not consume any resources after each Pod succeeds on every node.\nThis controller is particularly useful when upgrading a software, e.g., Kubelet, or validation check\nin every node, which is typically needed only once within a long period of time or\nrunning an adhoc full cluster inspection script."}),"\n",(0,l.jsx)(n.p,{children:"Optionally, a BroadcastJob can keep alive after all Pods on desired nodes complete\nso that a Pod will be automatically launched for every new node after it is added to the cluster."}),"\n",(0,l.jsx)(n.h2,{id:"spec-definition",children:"Spec definition"}),"\n",(0,l.jsx)(n.h3,{id:"template",children:"Template"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Template"})," describes the Pod template used to run the job.\nNote that for the Pod restart policy, only ",(0,l.jsx)(n.code,{children:"Never"})," or ",(0,l.jsx)(n.code,{children:"OnFailure"})," is allowed for BroadcastJob."]}),"\n",(0,l.jsx)(n.h3,{id:"parallelism",children:"Parallelism"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Parallelism"})," specifies the maximal desired number of Pods that should be run at\nany given time. By default, there's no limit."]}),"\n",(0,l.jsxs)(n.p,{children:["For example, if a cluster has ten nodes and ",(0,l.jsx)(n.code,{children:"Parallelism"})," is set to three, there can only be\nthree pods running in parallel. A new Pod is created only after one running Pod finishes."]}),"\n",(0,l.jsx)(n.h3,{id:"completionpolicy",children:"CompletionPolicy"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"CompletionPolicy"})," specifies the controller behavior when reconciling the BroadcastJob."]}),"\n",(0,l.jsx)(n.h4,{id:"always-default",children:"Always (default)"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Always"})," policy means the job will eventually complete with either failed or succeeded\ncondition. The following parameters take effect with this policy:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"ActiveDeadlineSeconds"})," specifies the duration in seconds relative to the startTime\nthat the job may be active before the system tries to terminate it.\nFor example, if ",(0,l.jsx)(n.code,{children:"ActiveDeadlineSeconds"})," is set to 60 seconds, after the BroadcastJob starts\nrunning for 60 seconds, all the running pods will be deleted and the job will be marked\nas Failed."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"TTLSecondsAfterFinished"})," limits the lifetime of a BroadcastJob that has finished execution\n(either Complete or Failed). For example, if TTLSecondsAfterFinished is set to 10 seconds,\nthe job will be kept for 10 seconds after it finishes. Then the job along with all the Pods\nwill be deleted."]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"never",children:"Never"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Never"})," policy means the BroadcastJob will never be marked as Failed or Succeeded even if\nall Pods run to completion. This also means above ",(0,l.jsx)(n.code,{children:"ActiveDeadlineSeconds"}),", ",(0,l.jsx)(n.code,{children:"TTLSecondsAfterFinished"}),"\nand ",(0,l.jsx)(n.code,{children:"FailurePolicy.RestartLimit"})," parameters takes no effect if ",(0,l.jsx)(n.code,{children:"Never"})," policy is used.\nFor example, if user wants to perform an initial configuration validation for every newly\nadded node in the cluster, he can deploy a BroadcastJob with ",(0,l.jsx)(n.code,{children:"Never"})," policy."]}),"\n",(0,l.jsx)(n.h3,{id:"failurepolicy",children:"FailurePolicy"}),"\n",(0,l.jsx)(n.h4,{id:"type",children:"Type"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Type"})," indicates the type of ",(0,l.jsx)(n.code,{children:"FailurePolicyType"}),"."]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Continue"})," means the job will be still running, when failed pod is found."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"FailFast"}),"(default) means the job will be failed, when failed pod is found."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Pause"})," means the job will be paused, when failed pod is found."]}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"restartlimit",children:"RestartLimit"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"RestartLimit"})," specifies the number of retries before marking the pod failed.\nCurrently, the number of retries are defined as the aggregated number of restart\ncounts across all Pods created by the job, i.e., the sum of the\n",(0,l.jsx)(n.a,{href:"https://github.com/kruiseio/kruise/blob/d61c12451d6a662736c4cfc48682fa75c73adcbc/vendor/k8s.io/api/core/v1/types.go#L2314",children:"ContainerStatus.RestartCount"}),"\nfor all containers in every Pod.  If this value exceeds ",(0,l.jsx)(n.code,{children:"RestartLimit"}),", the job is marked\nas Failed and all running Pods are deleted. No limit is enforced if ",(0,l.jsx)(n.code,{children:"RestartLimit"})," is\nnot set."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,l.jsx)(n.h3,{id:"monitor-broadcastjob-status",children:"Monitor BroadcastJob status"}),"\n",(0,l.jsxs)(n.p,{children:["Assuming the cluster has only one node, run ",(0,l.jsx)(n.code,{children:"kubectl get bcj"})," (shortcut name for BroadcastJob) and\nwe will see the following:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-shell",children:" NAME                 DESIRED   ACTIVE   SUCCEEDED   FAILED\n broadcastjob-sample  1         0        1           0\n"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Desired"})," : The number of desired Pods. This equals to the number of matched nodes in the cluster."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Active"}),": The number of active Pods."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"SUCCEEDED"}),": The number of succeeded Pods."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"FAILED"}),": The number of failed Pods."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"ttlsecondsafterfinished",children:"ttlSecondsAfterFinished"}),"\n",(0,l.jsxs)(n.p,{children:["Run a BroadcastJob that each Pod computes a pi, with ",(0,l.jsx)(n.code,{children:"ttlSecondsAfterFinished"})," set to 30.\nThe job will be deleted in 30 seconds after it is finished."]}),"\n",(0,l.jsxs)(i.A,{children:[(0,l.jsx)(r.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1beta1\nkind: BroadcastJob\nmetadata:\n  name: broadcastjob-ttl\nspec:\n  template:\n    spec:\n      containers:\n        - name: pi\n          image: perl\n          command: ["perl", "-Mbignum=bpi", "-wle", "print bpi(2000)"]\n      restartPolicy: Never\n  completionPolicy:\n    type: Always\n    ttlSecondsAfterFinished: 30\n'})})}),(0,l.jsx)(r.A,{value:"v1alpha1",label:"v1alpha1",children:(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: BroadcastJob\nmetadata:\n  name: broadcastjob-ttl\nspec:\n  template:\n    spec:\n      containers:\n        - name: pi\n          image: perl\n          command: ["perl", "-Mbignum=bpi", "-wle", "print bpi(2000)"]\n      restartPolicy: Never\n  completionPolicy:\n    type: Always\n    ttlSecondsAfterFinished: 30\n'})})})]}),"\n",(0,l.jsx)(n.h3,{id:"activedeadlineseconds",children:"activeDeadlineSeconds"}),"\n",(0,l.jsxs)(n.p,{children:["Run a BroadcastJob that each Pod sleeps for 50 seconds, with ",(0,l.jsx)(n.code,{children:"activeDeadlineSeconds"})," set to 10 seconds.\nThe job will be marked as Failed after it runs for 10 seconds, and the running Pods will be deleted."]}),"\n",(0,l.jsxs)(i.A,{children:[(0,l.jsx)(r.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1beta1\nkind: BroadcastJob\nmetadata:\n  name: broadcastjob-active-deadline\nspec:\n  template:\n    spec:\n      containers:\n        - name: sleep\n          image: busybox\n          command: ["sleep", "50000"]\n      restartPolicy: Never\n  completionPolicy:\n    type: Always\n    activeDeadlineSeconds: 10\n'})})}),(0,l.jsx)(r.A,{value:"v1alpha1",label:"v1alpha1",children:(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: BroadcastJob\nmetadata:\n  name: broadcastjob-active-deadline\nspec:\n  template:\n    spec:\n      containers:\n        - name: sleep\n          image: busybox\n          command: ["sleep", "50000"]\n      restartPolicy: Never\n  completionPolicy:\n    type: Always\n    activeDeadlineSeconds: 10\n'})})})]}),"\n",(0,l.jsx)(n.h3,{id:"completionpolicy-1",children:"completionPolicy"}),"\n",(0,l.jsxs)(n.p,{children:["Run a BroadcastJob with ",(0,l.jsx)(n.code,{children:"Never"})," completionPolicy. The job will continue to run even if all Pods have completed on all nodes."]}),"\n",(0,l.jsxs)(i.A,{children:[(0,l.jsx)(r.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1beta1\nkind: BroadcastJob\nmetadata:\n  name: broadcastjob-never-complete\nspec:\n  template:\n    spec:\n      containers:\n        - name: sleep\n          image: busybox\n          command: ["sleep", "5"]\n      restartPolicy: Never\n  completionPolicy:\n    type: Never\n'})})}),(0,l.jsx)(r.A,{value:"v1alpha1",label:"v1alpha1",children:(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: BroadcastJob\nmetadata:\n  name: broadcastjob-never-complete\nspec:\n  template:\n    spec:\n      containers:\n        - name: sleep\n          image: busybox\n          command: ["sleep", "5"]\n      restartPolicy: Never\n  completionPolicy:\n    type: Never\n'})})})]}),"\n",(0,l.jsx)(n.h3,{id:"failurepolicy-1",children:"failurePolicy"}),"\n",(0,l.jsx)(n.h4,{id:"restartlimit-1",children:"restartLimit"}),"\n",(0,l.jsxs)(n.p,{children:["Run a BroadcastJob with ",(0,l.jsx)(n.code,{children:"FailFast"})," failurePolicy. The job will be failed, when failed pod is found."]}),"\n",(0,l.jsxs)(i.A,{children:[(0,l.jsx)(r.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1beta1\nkind: BroadcastJob\nmetadata:\n  name: broadcastjob-restart-limit\nspec:\n  template:\n    spec:\n      containers:\n        - name: sleep\n          image: busybox\n          command: ["cat", "/path/not/exist"]\n      restartPolicy: Never\n  completionPolicy:\n    type: Never\n  failurePolicy:\n    type: FailFast\n    restartLimit: 3\n'})})}),(0,l.jsx)(r.A,{value:"v1alpha1",label:"v1alpha1",children:(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: BroadcastJob\nmetadata:\n  name: broadcastjob-restart-limit\nspec:\n  template:\n    spec:\n      containers:\n        - name: sleep\n          image: busybox\n          command: ["cat", "/path/not/exist"]\n      restartPolicy: Never\n  completionPolicy:\n    type: Never\n  failurePolicy:\n    type: FailFast\n    restartLimit: 3\n'})})})]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(h,{...e})}):h(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>r});var t=a(96540);const l={},s=t.createContext(l);function i(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),t.createElement(s.Provider,{value:n},e.children)}},65537:(e,n,a)=>{a.d(n,{A:()=>w});var t=a(96540),l=a(34164),s=a(65627),i=a(56347),r=a(50372),o=a(30604),c=a(11861),d=a(78749);function u(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:a}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return u(e).map((e=>{let{props:{value:n,label:a,attributes:t,default:l}}=e;return{value:n,label:a,attributes:t,default:l}}))}(a);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,a])}function p(e){let{value:n,tabValues:a}=e;return a.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:a}=e;const l=(0,i.W6)(),s=function(e){let{queryString:n=!1,groupId:a}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:n,groupId:a});return[(0,o.aZ)(s),(0,t.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(l.location.search);n.set(s,e),l.replace({...l.location,search:n.toString()})}),[s,l])]}function b(e){const{defaultValue:n,queryString:a=!1,groupId:l}=e,s=h(e),[i,o]=(0,t.useState)((()=>function(e){let{defaultValue:n,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=a.find((e=>e.default))??a[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:s}))),[c,u]=m({queryString:a,groupId:l}),[b,f]=function(e){let{groupId:n}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(n),[l,s]=(0,d.Dv)(a);return[l,(0,t.useCallback)((e=>{a&&s.set(e)}),[a,s])]}({groupId:l}),v=(()=>{const e=c??b;return p({value:e,tabValues:s})?e:null})();(0,r.A)((()=>{v&&o(v)}),[v]);return{selectedValue:i,selectValue:(0,t.useCallback)((e=>{if(!p({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);o(e),u(e),f(e)}),[u,f,s]),tabValues:s}}var f=a(9136);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var j=a(74848);function x(e){let{className:n,block:a,selectedValue:t,selectValue:i,tabValues:r}=e;const o=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.a_)(),d=e=>{const n=e.currentTarget,a=o.indexOf(n),l=r[a].value;l!==t&&(c(n),i(l))},u=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=o.indexOf(e.currentTarget)+1;n=o[a]??o[0];break}case"ArrowLeft":{const a=o.indexOf(e.currentTarget)-1;n=o[a]??o[o.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.A)("tabs",{"tabs--block":a},n),children:r.map((e=>{let{value:n,label:a,attributes:s}=e;return(0,j.jsx)("li",{role:"tab",tabIndex:t===n?0:-1,"aria-selected":t===n,ref:e=>{o.push(e)},onKeyDown:u,onClick:d,...s,className:(0,l.A)("tabs__item",v.tabItem,s?.className,{"tabs__item--active":t===n}),children:a??n},n)}))})}function y(e){let{lazy:n,children:a,selectedValue:s}=e;const i=(Array.isArray(a)?a:[a]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===s));return e?(0,t.cloneElement)(e,{className:(0,l.A)("margin-top--md",e.props.className)}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function g(e){const n=b(e);return(0,j.jsxs)("div",{className:(0,l.A)("tabs-container",v.tabList),children:[(0,j.jsx)(x,{...n,...e}),(0,j.jsx)(y,{...n,...e})]})}function w(e){const n=(0,f.A)();return(0,j.jsx)(g,{...e,children:u(e.children)},String(n))}},79329:(e,n,a)=>{a.d(n,{A:()=>i});a(96540);var t=a(34164);const l={tabItem:"tabItem_Ymn6"};var s=a(74848);function i(e){let{children:n,hidden:a,className:i}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,t.A)(l.tabItem,i),hidden:a,children:n})}}}]);