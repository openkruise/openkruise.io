"use strict";(self.webpackChunkopenkruise_io=self.webpackChunkopenkruise_io||[]).push([[839],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var t=s(96540);const i={},a=t.createContext(i);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(a.Provider,{value:n},e.children)}},29526:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"user-manuals/uniteddeployment","title":"UnitedDeployment","description":"This controller provides a new way to manage pods in multi-domain by using multiple workloads.","source":"@site/versioned_docs/version-v1.8/user-manuals/uniteddeployment.md","sourceDirName":"user-manuals","slug":"/user-manuals/uniteddeployment","permalink":"/docs/user-manuals/uniteddeployment","draft":false,"unlisted":false,"editUrl":"https://github.com/openkruise/openkruise.io/edit/master/docs/user-manuals/uniteddeployment.md","tags":[],"version":"v1.8","lastUpdatedBy":"Gautam Manchandani","lastUpdatedAt":1752802431000,"frontMatter":{"title":"UnitedDeployment"},"sidebar":"docs","previous":{"title":"WorkloadSpread","permalink":"/docs/user-manuals/workloadspread"},"next":{"title":"Container Restart","permalink":"/docs/user-manuals/containerrecreaterequest"}}');var i=s(74848),a=s(28453);const o={title:"UnitedDeployment"},l=void 0,r={},d=[{value:"Capacity Planning For Subsets",id:"capacity-planning-for-subsets",level:2},{value:"MaxReplicas Limits the Maximum Number of Replicas for a Subset",id:"maxreplicas-limits-the-maximum-number-of-replicas-for-a-subset",level:3},{value:"MinReplicas Ensures the Minimum Number of Replicas for a Subset",id:"minreplicas-ensures-the-minimum-number-of-replicas-for-a-subset",level:3},{value:"Customize pod configuration of subset",id:"customize-pod-configuration-of-subset",level:2},{value:"HPA UnitedDeployment",id:"hpa-uniteddeployment",level:2},{value:"Adaptive Scheduling Strategy",id:"adaptive-scheduling-strategy",level:2},{value:"Fixed Strategy",id:"fixed-strategy",level:3},{value:"Adaptive Strategy",id:"adaptive-strategy",level:3},{value:"Example: Hybrid Node Pool Scheduling Strategy",id:"example-hybrid-node-pool-scheduling-strategy",level:4},{value:"Scenario Description",id:"scenario-description",level:4},{value:"Pod Distribution Management",id:"pod-distribution-management",level:2},{value:"Pod Update Management",id:"pod-update-management",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["This controller provides a new way to manage pods in multi-domain by using multiple workloads.\nA high level description about this workload can be found in this ",(0,i.jsx)(n.a,{href:"/blog/uniteddeployment",children:"blog post"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Different domains in one Kubernetes cluster are represented by multiple groups of\nnodes identified by labels. UnitedDeployment controller provisions one type of workload\nfor each group of with corresponding matching ",(0,i.jsx)(n.code,{children:"NodeSelector"}),", so that\nthe pods created by individual workload will be scheduled to the target domain."]}),"\n",(0,i.jsxs)(n.p,{children:["Each workload managed by UnitedDeployment is called a ",(0,i.jsx)(n.code,{children:"subset"}),".\nEach domain should at least provide the capacity to run the ",(0,i.jsx)(n.code,{children:"replicas"})," number of pods.\nCurrently ",(0,i.jsx)(n.code,{children:"StatefulSet"}),", ",(0,i.jsx)(n.code,{children:"Advanced StatefulSet"}),", ",(0,i.jsx)(n.code,{children:"CloneSet"})," and ",(0,i.jsx)(n.code,{children:"Deployment"})," are the supported workloads."]}),"\n",(0,i.jsxs)(n.p,{children:["API definition: ",(0,i.jsx)(n.a,{href:"https://github.com/openkruise/kruise/blob/master/apis/apps/v1alpha1/uniteddeployment_types.go",children:"https://github.com/openkruise/kruise/blob/master/apis/apps/v1alpha1/uniteddeployment_types.go"})]}),"\n",(0,i.jsx)(n.p,{children:"The below sample yaml presents a UnitedDeployment which manages three StatefulSet instances in three domains.\nThe total number of managed pods is 6."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: UnitedDeployment\nmetadata:\n  name: sample-ud\nspec:\n  replicas: 6\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: sample\n  template:\n    # statefulSetTemplate or advancedStatefulSetTemplate or cloneSetTemplate or deploymentTemplate\n    statefulSetTemplate:\n      metadata:\n        labels:\n          app: sample\n      spec:\n        selector:\n          matchLabels:\n            app: sample\n        template:\n          metadata:\n            labels:\n              app: sample\n          spec:\n            containers:\n            - image: nginx:alpine\n              name: nginx\n  topology:\n    subsets:\n    - name: subset-a\n      nodeSelectorTerm:\n        matchExpressions:\n        - key: node\n          operator: In\n          values:\n          - zone-a\n      replicas: 1\n    - name: subset-b\n      nodeSelectorTerm:\n        matchExpressions:\n        - key: node\n          operator: In\n          values:\n          - zone-b\n      replicas: 50%\n    - name: subset-c\n      nodeSelectorTerm:\n        matchExpressions:\n        - key: node\n          operator: In\n          values:\n          - zone-c\n  updateStrategy:\n    manualUpdate:\n      partitions:\n        subset-a: 0\n        subset-b: 0\n        subset-c: 0\n    type: Manual\n...\n"})}),"\n",(0,i.jsx)(n.h2,{id:"capacity-planning-for-subsets",children:"Capacity Planning For Subsets"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.5.1"]}),"\n",(0,i.jsxs)(n.p,{children:["UnitedDeployment offer the option to define the ",(0,i.jsx)(n.code,{children:"MaxReplicas"})," for each subset, allowing you to effectively manage your resource allocation."]}),"\n",(0,i.jsx)(n.h3,{id:"maxreplicas-limits-the-maximum-number-of-replicas-for-a-subset",children:"MaxReplicas Limits the Maximum Number of Replicas for a Subset"}),"\n",(0,i.jsx)(n.p,{children:"For example, assuming there is an application that typically runs with a maximum of 4 replicas on regular nodes. However, if the number of replicas exceeds 4, the exceeded Pods will automatically scale them to elastic nodes."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: UnitedDeployment\nmetadata:\n  name: sample-ud\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: sample\n  template:\n    # statefulSetTemplate or advancedStatefulSetTemplate or cloneSetTemplate or deploymentTemplate\n    cloneSetTemplate:\n      ......\n  topology:\n    subsets:\n    - name: normal-nodes\n      maxReplicas: 4\n      ......\n    - name: elastic-nodes\n      maxReplicas: null\n      ......\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The UnitedDeployment controller follows the following rules for scaling each subset if you set ",(0,i.jsx)(n.code,{children:"MaxReplicas"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"When scaling up, the UnitedDeployment controller considers the order specified in the subsets list;"}),"\n",(0,i.jsx)(n.li,{children:"When scaling down, it obeys the reverse order of scaling up."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Please ",(0,i.jsx)(n.strong,{children:"Note"})," the following:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["You can ",(0,i.jsx)(n.strong,{children:"NOT"})," set both ",(0,i.jsx)(n.code,{children:"MaxReplicas"})," and ",(0,i.jsx)(n.code,{children:"Replicas"})," for any subset simultaneously."]}),"\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"MaxReplicas"})," is left empty (null), there are no limitations imposed on the number of replicas for that particular subset."]}),"\n",(0,i.jsxs)(n.li,{children:["To prevent situations where all ",(0,i.jsx)(n.code,{children:"MaxReplicas"})," requirements are met and no subsets can be scaled up, it is crucial to have ",(0,i.jsx)(n.strong,{children:"at least one"})," subset with an empty(null) ",(0,i.jsx)(n.code,{children:"MaxReplicas"})," value."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"minreplicas-ensures-the-minimum-number-of-replicas-for-a-subset",children:"MinReplicas Ensures the Minimum Number of Replicas for a Subset"}),"\n",(0,i.jsxs)(n.p,{children:["For example, when scattering by region, you can use ",(0,i.jsx)(n.code,{children:"minReplicas"})," to ensure that each region has at least one replica, while the remaining replicas are elastically deployed according to an adaptive scheduling strategy."]}),"\n",(0,i.jsx)(n.h2,{id:"customize-pod-configuration-of-subset",children:"Customize pod configuration of subset"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.5.0"]}),"\n",(0,i.jsx)(n.p,{children:"Since v1.5.0, one can customize pod spec field other than nodeSelectorTerm and tolerations, e.g. env, resources."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," it is not recommended to customize subset image since it may cause chaos into update function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: UnitedDeployment\nmetadata:\n  name: sample-ud\nspec:\n  replicas: 6\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: sample\n  template:\n    # statefulSetTemplate or advancedStatefulSetTemplate or cloneSetTemplate or deploymentTemplate\n    statefulSetTemplate:\n      ...\n  topology:\n    subsets:\n    - name: subset-a\n      ...\n      # patch container resources, env:\n      patch:\n        spec:\n          containers:\n          - name: main\n            resources:\n              limits:\n                cpu: "2"\n                memory: 800Mi\n            env:\n            - name: subset\n              value: subset-a\n    - name: subset-b\n      ...\n      # patch container resources, env:\n      patch:\n        spec:\n          containers:\n          - name: main\n            resources:\n              limits:\n                cpu: "2"\n                memory: 800Mi\n            env:\n            - name: subset\n              value: subset-b\n'})}),"\n",(0,i.jsx)(n.h2,{id:"hpa-uniteddeployment",children:"HPA UnitedDeployment"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.5.0"]}),"\n",(0,i.jsxs)(n.p,{children:["Horizontal Pod Autoscaler can support Custom Resource workload which has ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource",children:"scale subresource"}),".\nSince v1.5.0 you can HPA UnitedDeployment directly, as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: autoscaling/v2beta1\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: example-hpa\n  namespace: default\nspec:\n  minReplicas: 1\n  maxReplicas: 3\n  metrics:\n  - resource:\n      name: cpu\n      targetAverageUtilization: 2\n    type: Resource\n  scaleTargetRef:\n    apiVersion: apps.kruise.io/v1alpha1\n    kind: UnitedDeployment\n    name: sample-ud\n"})}),"\n",(0,i.jsx)(n.h2,{id:"adaptive-scheduling-strategy",children:"Adaptive Scheduling Strategy"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.8.0"]}),"\n",(0,i.jsxs)(n.p,{children:["UnitedDeployment supports configuring two different scheduling strategies through the ",(0,i.jsx)(n.code,{children:"scheduleStrategy"})," field: ",(0,i.jsx)(n.strong,{children:"Fixed"})," and ",(0,i.jsx)(n.strong,{children:"Adaptive"}),". The behaviors of these two strategies are as follows:"]}),"\n",(0,i.jsx)(n.h3,{id:"fixed-strategy",children:"Fixed Strategy"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Behavior"}),": Strictly follows the predefined Subset distribution rules to schedule Pods. Even if Pod scheduling fails due to insufficient node resources or scheduling conflicts, it will continue attempting to schedule within the original Subset."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Cases"}),": Scenarios requiring precise control over workload distribution, such as environments with specific node resource isolation or high compliance requirements."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"adaptive-strategy",children:"Adaptive Strategy"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Behavior"}),": When the target Subset cannot schedule a Pod, it automatically schedules the Pod to other Subsets with available resources. The scheduling priority follows the order of the Subset list."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Features"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Resource Reschedule"}),": When a Subset has insufficient resources, pods are automatically rescheduled to other subsets."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configurable Rescheduling Timeout"}),": The rescheduling determination time window can be set using the ",(0,i.jsx)(n.code,{children:"rescheduleCriticalSeconds"})," parameter (default is 30 seconds)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Cases"}),": Scenarios requiring highly elastic resource scheduling, such as hybrid usage of regular node pools and elastic node pools."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"example-hybrid-node-pool-scheduling-strategy",children:"Example: Hybrid Node Pool Scheduling Strategy"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: UnitedDeployment\nmetadata:\n  name: ud-demo\nspec:\n  #...\n  topology:\n    subsets:\n    - name: subset-a\n      maxReplicas: 3\n      #...\n    - name: subset-b\n      #...\n    scheduleStrategy:\n      # Scheduling strategy. Adaptive mode will reschedule failed Pods to other\n      type: Adaptive\n      adaptive:\n        rescheduleCriticalSeconds: 30\n"})}),"\n",(0,i.jsx)(n.h4,{id:"scenario-description",children:"Scenario Description"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Off-Peak Period"}),": Prioritizes scheduling Pods in the regular node pool (subset-a) to fully utilize fixed resources."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Peak Period"}),": When subset-a's node resources are insufficient, Pods exceeding ",(0,i.jsx)(n.code,{children:"maxReplicas"})," are automatically scheduled to the elastic node pool (subset-b)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Failure Recovery"}),": When all nodes in subset-a become unavailable, all new Pods will automatically migrate to subset-b."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"pod-distribution-management",children:"Pod Distribution Management"}),"\n",(0,i.jsxs)(n.p,{children:["This controller provides ",(0,i.jsx)(n.code,{children:"spec.topology"})," to describe the pod distribution specification."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Topology defines the spread detail of each subset under UnitedDeployment.\n// A UnitedDeployment manages multiple homogeneous workloads which are called subset.\n// Each of subsets under the UnitedDeployment is described in Topology.\ntype Topology struct {\n    // Contains the details of each subset. Each element in this array represents one subset\n    // which will be provisioned and managed by UnitedDeployment.\n    // +optional\n    Subsets []Subset `json:"subsets,omitempty"`\n}\n\n// Subset defines the detail of a subset.\ntype Subset struct {\n    // Indicates subset name as a DNS_LABEL, which will be used to generate\n    // subset workload name prefix in the format \'<deployment-name>-<subset-name>-\'.\n    // Name should be unique between all of the subsets under one UnitedDeployment.\n    Name string `json:"name"`\n\n    // Indicates the node selector to form the subset. Depending on the node selector,\n    // pods provisioned could be distributed across multiple groups of nodes.\n    // A subset\'s nodeSelectorTerm is not allowed to be updated.\n    // +optional\n    NodeSelectorTerm corev1.NodeSelectorTerm `json:"nodeSelectorTerm,omitempty"`\n\n    // Indicates the tolerations the pods under this subset have.\n    // A subset\'s tolerations is not allowed to be updated.\n    // +optional\n    Tolerations []corev1.Toleration `json:"tolerations,omitempty"`\n\n    // Indicates the number of the pod to be created under this subset. Replicas could also be\n    // percentage like \'10%\', which means 10% of UnitedDeployment replicas of pods will be distributed\n    // under this subset. If nil, the number of replicas in this subset is determined by controller.\n    // Controller will try to keep all the subsets with nil replicas have average pods.\n    // +optional\n    Replicas *intstr.IntOrString `json:"replicas,omitempty"`\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"topology.subsets"})," specifies the desired group of ",(0,i.jsx)(n.code,{children:"subset"}),"s.\nA subset added to or removed from this array will be created or deleted by controller during reconcile.\nEach subset workload is created based on the description of UnitedDeployment ",(0,i.jsx)(n.code,{children:"spec.template"}),".\n",(0,i.jsx)(n.code,{children:"subset"})," provides the necessary topology information to create a subset workload.\nEach subset has a unique name.  A subset workload is created with the name prefix in\nformat of ",(0,i.jsx)(n.code,{children:"<UnitedDeployment-name>-<Subset-name>-"}),". Each subset will also be configured with\nthe ",(0,i.jsx)(n.code,{children:"nodeSelector"}),".\nWhen provisioning a StatefulSet ",(0,i.jsx)(n.code,{children:"subset"}),", the ",(0,i.jsx)(n.code,{children:"nodeSelector"})," will be added\nto the StatefulSet's ",(0,i.jsx)(n.code,{children:"podTemplate"}),", so that the Pods of the StatefulSet will be created with the\nexpected node affinity."]}),"\n",(0,i.jsx)(n.p,{children:"By default, UnitedDeployment's Pods are evenly distributed across all subsets.\nThere are two scenarios the controller does not follow this policy:"}),"\n",(0,i.jsxs)(n.p,{children:["The first one is to customize the distribution policy by indicating ",(0,i.jsx)(n.code,{children:"subset.replicas"}),".\nA valid ",(0,i.jsx)(n.code,{children:"subset.replicas"})," could be integer to represent a ",(0,i.jsx)(n.strong,{children:"real replicas of pods"})," or\n",(0,i.jsx)(n.strong,{children:"string in format of percentage"})," like '40%' to represent a fixed proportion of pods.\nOnce a ",(0,i.jsx)(n.code,{children:"subset.replicas"})," is given, the controller is going to reconcile to make sure\neach subset has the expected replicas.\nThe subsets with empty ",(0,i.jsx)(n.code,{children:"subset.replicas"})," will divide the remaining replicas evenly."]}),"\n",(0,i.jsxs)(n.p,{children:["The other scenario is that the indicated subset replicas policy becomes invalid.\nFor example, the UnitedDeployment's ",(0,i.jsx)(n.code,{children:"spec.replicas"})," is decremented to be less\nthan the sum of all ",(0,i.jsx)(n.code,{children:"subset.replicas"}),".\nIn this case, the indicated ",(0,i.jsx)(n.code,{children:"subset.replicas"})," is ineffective and the controller\nwill automatically scale each subset's replicas to match the total replicas number.\nThe controller will try its best to apply this adjustment smoothly."]}),"\n",(0,i.jsx)(n.h2,{id:"pod-update-management",children:"Pod Update Management"}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"spec.template"})," is updated, a upgrade progress will be triggered.\nNew template will be patch to each subset workload, which triggers subset controller\nto update their pods.\nFurthermore, if subset workload supports ",(0,i.jsx)(n.code,{children:"partition"}),", like StatefulSet, AdvancedStatefulSet\nis also able to provide ",(0,i.jsx)(n.code,{children:"Manual"})," update strategy."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// UnitedDeploymentUpdateStrategy defines the update performance\n// when template of UnitedDeployment is changed.\ntype UnitedDeploymentUpdateStrategy struct {\n    // Type of UnitedDeployment update strategy.\n    // Default is Manual.\n    // +optional\n    Type UpdateStrategyType `json:"type,omitempty"`\n    // Includes all of the parameters a Manual update strategy needs.\n    // +optional\n    ManualUpdate *ManualUpdate `json:"manualUpdate,omitempty"`\n}\n\n// ManualUpdate is a update strategy which allows users to control the update progress\n// by providing the partition of each subset.\ntype ManualUpdate struct {\n    // Indicates number of subset partition.\n    // +optional\n    Partitions map[string]int32 `json:"partitions,omitempty"`\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Manual"})," update strategy allows users to control the update progress by indicating\nthe ",(0,i.jsx)(n.code,{children:"partition"})," of each subset. The controller will pass the ",(0,i.jsx)(n.code,{children:"partition"})," to each subset."]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);