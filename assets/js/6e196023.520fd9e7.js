"use strict";(self.webpackChunkopenkruise_io=self.webpackChunkopenkruise_io||[]).push([[1929],{4051:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"user-manuals/sidecarset","title":"SidecarSet","description":"This controller leverages the admission webhook to automatically","source":"@site/docs/user-manuals/sidecarset.md","sourceDirName":"user-manuals","slug":"/user-manuals/sidecarset","permalink":"/docs/next/user-manuals/sidecarset","draft":false,"unlisted":false,"editUrl":"https://github.com/openkruise/openkruise.io/edit/master/docs/user-manuals/sidecarset.md","tags":[],"version":"current","lastUpdatedBy":"Marco","lastUpdatedAt":1766368514000,"frontMatter":{"title":"SidecarSet"},"sidebar":"docs","previous":{"title":"AdvancedCronJob","permalink":"/docs/next/user-manuals/advancedcronjob"},"next":{"title":"Job Sidecar Terminator","permalink":"/docs/next/user-manuals/jobsidecarterminator"}}');var i=a(74848),s=a(28453),r=a(65537),o=a(79329);const l={title:"SidecarSet"},c=void 0,d={},h=[{value:"Example",id:"example",level:2},{value:"Create SidecarSet",id:"create-sidecarset",level:3},{value:"Create a Pod",id:"create-a-pod",level:3},{value:"update sidecar container Image",id:"update-sidecar-container-image",level:3},{value:"SidecarSet features",id:"sidecarset-features",level:2},{value:"namespace selector",id:"namespace-selector",level:4},{value:"sidecar container injection",id:"sidecar-container-injection",level:3},{value:"injection pause",id:"injection-pause",level:4},{value:"imagePullSecrets",id:"imagepullsecrets",level:4},{value:"Injection ResourcesPolicy",id:"injection-resourcespolicy",level:4},{value:"version control for injection",id:"version-control-for-injection",level:3},{value:"select revision via ControllerRevision name",id:"select-revision-via-controllerrevision-name",level:4},{value:"select revision via custom version label",id:"select-revision-via-custom-version-label",level:4},{value:"Support for Partial Injection Strategy",id:"support-for-partial-injection-strategy",level:4},{value:"support k8s 1.28 Sidecar Containers",id:"support-k8s-128-sidecar-containers",level:3},{value:"sidecarset update strategy",id:"sidecarset-update-strategy",level:3},{value:"partition",id:"partition",level:4},{value:"MaxUnavailable",id:"maxunavailable",level:4},{value:"Pause",id:"pause",level:4},{value:"Selector",id:"selector",level:4},{value:"sidecarset update order",id:"sidecarset-update-order",level:3},{value:"scatter",id:"scatter",level:4},{value:"priority",id:"priority",level:4},{value:"Hot Upgrade Sidecar",id:"hot-upgrade-sidecar",level:3},{value:"Inject Containers",id:"inject-containers",level:4},{value:"Hot Upgrade",id:"hot-upgrade",level:4},{value:"Migration Demo",id:"migration-demo",level:4},{value:"Inject Pod Metadata (Annotations)",id:"inject-pod-metadata-annotations",level:3},{value:"Metadata WhiteList",id:"metadata-whitelist",level:4},{value:"Feature-gate",id:"feature-gate",level:4},{value:"SidecarSet Status",id:"sidecarset-status",level:3},{value:"How to troubleshoot SidecarSet in-place upgrade blocking",id:"how-to-troubleshoot-sidecarset-in-place-upgrade-blocking",level:2}];function p(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["This controller leverages the admission webhook to automatically\ninject a sidecar container for every selected Pod when the Pod is created. The Sidecar\ninjection process is similar to the automatic sidecar injection mechanism used in\n",(0,i.jsx)(n.a,{href:"https://istio.io/docs/setup/kubernetes/additional-setup/sidecar-injection/",children:"istio"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Besides injection during Pod creation, SidecarSet controller also provides\nadditional capabilities such as in-place Sidecar container image upgrade, mounting Sidecar volumes, etc.\nBasically, SidecarSet decouples the Sidecar container lifecycle\nmanagement from the main container lifecycle management."}),"\n",(0,i.jsx)(n.p,{children:"The SidecarSet is preferable for managing stateless sidecar containers such as\nmonitoring tools or operation agents."}),"\n",(0,i.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.h3,{id:"create-sidecarset",children:"Create SidecarSet"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"sidecarset.yaml"})," file below describes a SidecarSet that contains a sidecar container named ",(0,i.jsx)(n.code,{children:"sidecar1"}),":"]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# sidecarset.yaml\napiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: test-sidecarset\nspec:\n  selector:\n    matchLabels:\n      app: nginx\n  updateStrategy:\n    type: RollingUpdate\n    maxUnavailable: 1\n  containers:\n  - name: sidecar1\n    image: centos:6.7\n    command: ["sleep", "999d"] # do nothing at all\n    volumeMounts:\n    - name: log-volume\n      mountPath: /var/log\n  volumes: # this field will be merged into pod.spec.volumes\n  - name: log-volume\n    emptyDir: {}\n'})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# sidecarset.yaml\napiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: test-sidecarset\nspec:\n  selector:\n    matchLabels:\n      app: nginx\n  updateStrategy:\n    type: RollingUpdate\n    maxUnavailable: 1\n  containers:\n  - name: sidecar1\n    image: centos:6.7\n    command: ["sleep", "999d"] # do nothing at all\n    volumeMounts:\n    - name: log-volume\n      mountPath: /var/log\n  volumes: # this field will be merged into pod.spec.volumes\n  - name: log-volume\n    emptyDir: {}\n'})})})]}),"\n",(0,i.jsx)(n.p,{children:"Create a SidecarSet based on the YAML file:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f sidecarset.yaml\n"})}),"\n",(0,i.jsx)(n.h3,{id:"create-a-pod",children:"Create a Pod"}),"\n",(0,i.jsx)(n.p,{children:"Create a pod that matches the sidecarset's selector:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    app: nginx # matches the SidecarSet's selector\n  name: test-pod\nspec:\n  containers:\n  - name: app\n    image: nginx:1.15.1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Create this pod and now you will find it's injected with ",(0,i.jsx)(n.code,{children:"sidecar1"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ kubectl get pod\nNAME       READY   STATUS    RESTARTS   AGE\ntest-pod   2/2     Running   0          118s\n"})}),"\n",(0,i.jsx)(n.p,{children:"In the meantime, the SidecarSet status updated:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ kubectl get sidecarset test-sidecarset -o yaml | grep -A4 status\nstatus:\n  matchedPods: 1\n  observedGeneration: 1\n  readyPods: 1\n  updatedPods: 1\n"})}),"\n",(0,i.jsx)(n.h3,{id:"update-sidecar-container-image",children:"update sidecar container Image"}),"\n",(0,i.jsx)(n.p,{children:"update sidecarSet's sidecar container image=centos:7"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ kubectl edit sidecarsets test-sidecarset\n\n# sidecarset.yaml\napiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: test-sidecarset\nspec:\n  containers:\n    - name: sidecar1\n      image: centos:7\n"})}),"\n",(0,i.jsx)(n.p,{children:"The Sidecar container in the pod has been updated to centos:7, and the pod and other containers have not been restarted."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'$ kubectl get pods | grep test-pod\ntest-pod                            2/2     Running   1          7m34s\n\n$ kubectl get pods test-pod -o yaml | grep \'image: centos\'\n    image: centos:7\n\n$ kubectl describe pods test-pod\nEvents:\n  Type    Reason     Age                 From               Message\n  ----    ------     ----                ----               -------\n  Normal  Killing    5m47s               kubelet            Container sidecar1 definition changed, will be restarted\n  Normal  Pulling    5m17s               kubelet            Pulling image "centos:7"\n  Normal  Created    5m5s (x2 over 12m)  kubelet            Created container sidecar1\n  Normal  Started    5m5s (x2 over 12m)  kubelet            Started container sidecar1\n  Normal  Pulled     5m5s                kubelet            Successfully pulled image "centos:7"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"sidecarset-features",children:"SidecarSet features"}),"\n",(0,i.jsx)(n.p,{children:"A sample SidecarSet yaml looks like following:"}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  selector:\n    matchLabels:\n      app: sample\n  containers:\n  - name: nginx\n    image: nginx:alpine\n  initContainers:\n  - name: init-container\n    image: busybox:latest\n    command: [ "/bin/sh", "-c", "sleep 5 && echo \'init container success\'" ]\n  updateStrategy:\n    type: RollingUpdate\n  namespaceSelector:\n    matchLabels:\n      kubernetes.io/metadata.name: ns-1\n'})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  selector:\n    matchLabels:\n      app: sample\n  containers:\n  - name: nginx\n    image: nginx:alpine\n  initContainers:\n  - name: init-container\n    image: busybox:latest\n    command: [ "/bin/sh", "-c", "sleep 5 && echo \'init container success\'" ]\n  updateStrategy:\n    type: RollingUpdate\n  namespace: ns-1\n'})})})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["spec.selector Select the POD that needs to be injected and updated by Label. MatchLabels and MatchExpressions are supported. Please refer to the details: ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/",children:"https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/"})]}),"\n",(0,i.jsxs)(n.li,{children:["spec.containers Define pod.spec.containers[x] that need to be injected and updated, supporting the full K8S Container field. Please refer to the details: ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/containers/",children:"https://kubernetes.io/docs/concepts/containers/"})]}),"\n",(0,i.jsxs)(n.li,{children:["spec.initContainers Define the pod.spec.initContainers[x] you need to inject, supporting the full K8S InitContainer field. Please refer to the details\uff1a",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",children:"https://kubernetes.io/docs/concepts/workloads/pods/init-containers/"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"We will inject those containers by their name in ascending order"}),"\n",(0,i.jsx)(n.li,{children:"InitContainers only support injection and do not support POD in-place update"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["spec.updateStrategy sidecarSet update strategy, type indicates the upgrade method:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"NotUpdate No updates, in this type only inject sidecar containers in pod"}),"\n",(0,i.jsx)(n.li,{children:"RollingUpdate Injection and rolling update, which contains a rich update strategy, will be described in more detail later"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"spec.namespace By default, sidecarset is cluster scope in k8s, that is, for all namespaces (except kube-system, kube-public). When spec.namespace field set, it only applies to pods of that namespace"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," Since Kruise v1.3.0, SidecarSet no longer excludes the namespace ",(0,i.jsx)(n.strong,{children:"kube-system, kube-public"})," by default.\nIf you want to exclude some namespaces, please use the following namespace selector."]}),"\n",(0,i.jsx)(n.h4,{id:"namespace-selector",children:"namespace selector"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.4.0"]}),"\n",(0,i.jsxs)(n.p,{children:["The spec.namespace field can only specify one Namespace and cannot exclude specific Namespaces. If facing complex namespace selector scenarios,\nit is recommended to use the ",(0,i.jsx)(n.strong,{children:"namespaceSelector"})," field:"]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  ...\n  namespaceSelector:\n    matchLabels:\n      environment: production\n  # matchExpressions:\n  # - {key: tier, operator: In, values: [frontend, middleware]}\n"})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  ...\n  namespace: ns1\n  namespaceSelector:\n    matchLabels:\n      environment: production\n  # matchExpressions:\n  # - {key: tier, operator: In, values: [frontend, middleware]}\n"})})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Note: Starting from ",(0,i.jsx)(n.a,{href:"https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.21.md?plain=1#L1819",children:"kubernetes 1.21"}),", Namespace will be labeled with ",(0,i.jsx)(n.code,{children:"kubernetes.io/metadata.name"})," by default, so the ",(0,i.jsx)(n.code,{children:"spec.namespace"})," field has been removed in SidecarSet v1beta1 version. If your version meets the requirements, you can use ",(0,i.jsx)(n.code,{children:"spec.namespaceSelector"})," alone to filter Namespaces."]})}),"\n",(0,i.jsx)(n.h3,{id:"sidecar-container-injection",children:"sidecar container injection"}),"\n",(0,i.jsx)(n.p,{children:"The injection of sidecar containers happens at Pod creation time and only Pod spec is updated. The workload template spec will not be updated.\nIn addition to the default K8s Container field, the following fields have been extended to injection:"}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  selector:\n    matchLabels:\n      app: sample\n  containers:\n    # default K8s Container fields\n  - name: nginx\n    image: nginx:alpine\n    volumeMounts:\n    - mountPath: /nginx/conf\n      name: nginx.conf\n    # extended sidecar container fields\n    podInjectPolicy: BeforeAppContainer\n    shareVolumePolicy:\n      type: disabled | enabled\n    transferEnv:\n    - sourceContainerName: main\n      envName: PROXY_IP\n    - sourceContainerNameFrom:\n        fieldRef:\n          apiVersion: "v1"\n          fieldPath: "metadata.labels[\'cName\']"\n        # fieldPath: "metadata.annotations[\'cName\']"\n      envName: TC\n  volumes:\n  - name: nginx.conf\n    hostPath:\n      path: /data/nginx/conf\n'})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  selector:\n    matchLabels:\n      app: sample\n  containers:\n    # default K8s Container fields\n  - name: nginx\n    image: nginx:alpine\n    resourcesPolicy: # extended sidecar container fields\n      targetContainersMode: sum # sum | max, TargetContainersMode defines how to aggregate resources from target containers. Sum means sum up all target containers\' resources, max means choose the max value of each resource\n      targetContainersNameRegex: ^nginx$ # only applies to container nginx\n      resourcesExpr:\n        limits:\n          cpu: max(cpu*50%, 100m)\n          memory: max(memory*50%, 200Mi)\n        requests:\n          cpu: max(cpu*40%, 50m)\n          memory: max(memory*40%, 100Mi)\n    volumeMounts:\n    - mountPath: /nginx/conf\n      name: nginx.conf\n    # extended sidecar container fields\n    podInjectPolicy: BeforeAppContainer\n    shareVolumePolicy:\n      type: disabled | enabled\n    transferEnv:\n    - sourceContainerName: main\n      envName: PROXY_IP\n    - sourceContainerNameFrom:\n        fieldRef:\n          apiVersion: "v1"\n          fieldPath: "metadata.labels[\'cName\']"\n        # fieldPath: "metadata.annotations[\'cName\']"\n      envName: TC\n  volumes:\n  - name: nginx.conf\n    hostPath:\n      path: /data/nginx/conf\n'})})})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["podInjectPolicy Define where Containers are injected into pod.spec.containers","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"BeforeAppContainer(default) Inject into the front of the original pod containers"}),"\n",(0,i.jsx)(n.li,{children:"AfterAppContainer Inject into the backend of the original pod containers"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["data volume sharing","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Share specific volumes: Use spec.volumes to define the volumes needed by Sidecar itself. See details\uff1a",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/storage/volumes/",children:"https://kubernetes.io/docs/concepts/storage/volumes/"})]}),"\n",(0,i.jsx)(n.li,{children:"Share pod containers volumes: If ShareVolumePolicy.type is enabled, the sidecar container will share the other container's VolumeMounts in the pod(don't contains the injected sidecar container)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Environment variable sharing","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Environment variables can be fetched from another container through spec.containers[x].transferenv, and the environment variable named envName from the container named sourceContainerName is copied to this container"}),"\n",(0,i.jsxs)(n.li,{children:["sourceContainerNameFrom support downwardAPI for container name, such as ",(0,i.jsx)(n.code,{children:"metadata.labels['<KEY>']"}),", ",(0,i.jsx)(n.code,{children:"metadata.annotations['<KEY>']"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Injection ResourcesPolicy","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["User can configure the resource expression for sidecar container to dynamically adjust its resources based on the target container's resources by field ",(0,i.jsx)(n.code,{children:".spec.containers[i].resourcesPolicy"})," and ",(0,i.jsx)(n.code,{children:".spec.initContainers[i].resourcesPolicy"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"injection-pause",children:"injection pause"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v0.10.0"]}),"\n",(0,i.jsxs)(n.p,{children:["For existing SidecarSets\uff0cusers can pause sidecar injection by setting ",(0,i.jsx)(n.code,{children:"spec.injectionStrategy.paused=true"}),"\uff1a"]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  ... ...\n  injectionStrategy:\n    paused: true\n"})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  ... ...\n  injectionStrategy:\n    paused: true\n"})})})]}),"\n",(0,i.jsx)(n.p,{children:"This feature only works on the newly-created Pods, and has no impact on the sidecar containers that have been injected."}),"\n",(0,i.jsx)(n.h4,{id:"imagepullsecrets",children:"imagePullSecrets"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v0.10.0"]}),"\n",(0,i.jsxs)(n.p,{children:["The SidecarSet can be configured with spec.imagePullSecrets to pull private sidecar images with ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/zh/docs/concepts/configuration/secret/",children:"Secret"})," . When sidecar is injected, SidecarSet injects its spec.imagePullSecrets into Pods ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/",children:"spec.imagePullSecrets"}),"."]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  ... ....\n  imagePullSecrets:\n  - name: my-secret\n"})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  ... ....\n  imagePullSecrets:\n  - name: my-secret\n"})})})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"}),": Users must ensure that the corresponding Secrets have already existed in the namespaces where Pods need to pull the private images. Otherwise, pulling private images will not succeed."]}),"\n",(0,i.jsx)(n.h4,{id:"injection-resourcespolicy",children:"Injection ResourcesPolicy"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.9.0"]}),"\n",(0,i.jsx)(n.p,{children:"SidecarSet supports configuring sidecar container resources based on pod specifications during pod creation."}),"\n",(0,i.jsxs)(n.p,{children:["For design documentation, please refer to: ",(0,i.jsx)(n.a,{href:"https://github.com/openkruise/kruise/blob/master/docs/proposals/20250913-sidecarset-dynamic-resources-when-creating.md",children:"proposals sidecarset dynamic resources when pod creating"}),". Best practice: ",(0,i.jsx)(n.a,{href:"/docs/next/best-practices/resource-policy-sidecarset",children:"Dynamic Resource Injection with SidecarSet"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nspec:\n  containers:\n  - name: sidecar1\n    image: centos:6.7\n    resourcesPolicy:\n      targetContainersMode: sum\n      targetContainersNameRegex: ^large-engine-v4$ # only applies to container large-engine-v4\n      resourcesExpr:\n        limits:\n          cpu: max(cpu*50%, 50m)\n          memory: 200Mi\n        requests:\n          cpu: max(cpu*50%, 50m)\n          memory: 100Mi\n---\napiVersion: v1\nkind: Pod\nspec:\n  containers:\n  - name: large-engine-v4\n    image: nginx:1.14.2\n    resources:\n      limits:\n        cpu: 200m\n        memory: 200Mi\n      requests:\n        cpu: 50m\n        memory: 100Mi\n  - name: large-engine-v8\n    image: nginx:1.14.2\n    resources:\n      limits:\n        cpu: 200m\n        memory: 200Mi\n      requests:\n        cpu: 50m\n        memory: 100Mi\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this case, the sidecar container resources will be:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"limits:\n  cpu: max(sum(200m) * 50%, 50m ) = 100m\n  memory: 200Mi\nrequests:\n  cpu: max(sum(50m) * 50%, 50m ) = 50m\n  memory: 100Mi\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Supported expression operators:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Basic arithmetic: ",(0,i.jsx)(n.code,{children:"+"}),", ",(0,i.jsx)(n.code,{children:"-"}),", ",(0,i.jsx)(n.code,{children:"*"}),", ",(0,i.jsx)(n.code,{children:"/"})]}),"\n",(0,i.jsxs)(n.li,{children:["Parentheses: ",(0,i.jsx)(n.code,{children:"("})," and ",(0,i.jsx)(n.code,{children:")"})]}),"\n",(0,i.jsxs)(n.li,{children:["Functions: ",(0,i.jsx)(n.code,{children:"max()"}),", ",(0,i.jsx)(n.code,{children:"min()"})]}),"\n",(0,i.jsxs)(n.li,{children:["Percentages: e.g., ",(0,i.jsx)(n.code,{children:"50%"})," (equals 0.5)"]}),"\n",(0,i.jsxs)(n.li,{children:["Kubernetes resources: e.g., ",(0,i.jsx)(n.code,{children:"40m"})," (40 millicores), ",(0,i.jsx)(n.code,{children:"100Mi"})," (100 mebibytes)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Supported expression value types:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Integers: e.g., ",(0,i.jsx)(n.code,{children:"42"})]}),"\n",(0,i.jsxs)(n.li,{children:["Floating-point numbers: e.g., ",(0,i.jsx)(n.code,{children:"3.14"})]}),"\n",(0,i.jsxs)(n.li,{children:["Percentages: e.g., ",(0,i.jsx)(n.code,{children:"50%"})," (automatically converted to 0.5)"]}),"\n",(0,i.jsxs)(n.li,{children:["Kubernetes resources: e.g., ",(0,i.jsx)(n.code,{children:"200m"}),", ",(0,i.jsx)(n.code,{children:"512Mi"}),", ",(0,i.jsx)(n.code,{children:"1Gi"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["If both ",(0,i.jsx)(n.code,{children:"resourcesPolicy"})," and ",(0,i.jsx)(n.code,{children:"resources"})," are configured, the Kruise validating webhook will reject the Pod creation request."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"targetContainersNameRegex"})," is a regular expression pattern for matching target container names. If no container names match this regex, the validating webhook will reject the Pod creation request. Target containers include native sidecar containers and regular containers, but exclude Kruise sidecar containers."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"resourcesPolicy"})," can be applied to both native sidecar containers (",(0,i.jsx)(n.code,{children:"sidecarset.spec.initContainers.resourcesPolicy"}),") and regular containers (",(0,i.jsx)(n.code,{children:"sidecarset.spec.containers.resourcesPolicy"}),")."]}),"\n",(0,i.jsx)(n.li,{children:"Injection only happened when pod creating, and will not be updated when pod running."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"version-control-for-injection",children:"version control for injection"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.3.0"]}),"\n",(0,i.jsxs)(n.p,{children:["SidecarSet will record historical revision of some fields such as ",(0,i.jsx)(n.code,{children:"containers"}),", ",(0,i.jsx)(n.code,{children:"volumes"}),", ",(0,i.jsx)(n.code,{children:"initContainers"}),", ",(0,i.jsx)(n.code,{children:"imagePullSecrets"})," and ",(0,i.jsx)(n.code,{children:"patchPodMetadata"})," via ControllerRevision. You can easily select a specific historical revision to inject when creating Pods, rather than always inject the latest revision of sidecar."]}),"\n",(0,i.jsx)(n.p,{children:"Based on this feature, users can address the risk of SidecarSet publishing due to scaling and rolling workload."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Note: SidecarSet records ControllerRevision in the same namespace as Kruise Manager. You can execute ",(0,i.jsx)(n.code,{children:"kubectl get controllerrevisions -n kruise-system -l kruise.io/sidecarset-name=<your-sidecarset-name>"})," to list the ControllerRevisions of your SidecarSet. Moreover, the ControllerRevision name of current SidecarSet revision is shown in ",(0,i.jsx)(n.code,{children:"status.latestRevision"})," field, so you can record it very easily."]})}),"\n",(0,i.jsx)(n.h4,{id:"select-revision-via-controllerrevision-name",children:"select revision via ControllerRevision name"}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  ...\n  injectionStrategy:\n    revision:\n      revisionName: <specific-controllerrevision-name>\n"})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  ...\n  injectionStrategy:\n    revision:\n      revisionName: <specific-controllerrevision-name>\n"})})})]}),"\n",(0,i.jsx)(n.h4,{id:"select-revision-via-custom-version-label",children:"select revision via custom version label"}),"\n",(0,i.jsxs)(n.p,{children:["You can add or update the label ",(0,i.jsx)(n.code,{children:"apps.kruise.io/sidecarset-custom-version=<your-version-id>"})," to SidecarSet when creating or publishing SidecarSet, to mark each historical revision. SidecarSet will bring this label down to the corresponding ControllerRevision object, and you can easily use the ",(0,i.jsx)(n.code,{children:"<your-version-id>"})," to describe which historical revision you want to inject."]}),"\n",(0,i.jsxs)(n.p,{children:["Assume that you are publishing ",(0,i.jsx)(n.code,{children:"version-2"})," in canary way (you wish only 10% Pods will be upgraded), and you want to inject the stable ",(0,i.jsx)(n.code,{children:"version-1"})," to newly-created Pods to reduce the risk of the canary publishing:"]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  ...\n  customVersion: version-2\n  updateStrategy:\n    partition: 90%\n  injectionStrategy:\n    revision:\n      customVersion: version-1\n"})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\n  labels:\n    apps.kruise.io/sidecarset-custom-version: version-2\nspec:\n  ...\n  updateStrategy:\n    partition: 90%\n  injectionStrategy:\n    revision:\n      customVersion: version-1\n"})})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Just choose one of the ways above."})}),"\n",(0,i.jsx)(n.h4,{id:"support-for-partial-injection-strategy",children:"Support for Partial Injection Strategy"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.8.0"]}),"\n",(0,i.jsx)(n.p,{children:"Although previous version selection methods (specifying a specific revision or customVersion) can control the injection version for new Pods, during proportional canary releases,\nit may be necessary to inject sidecars of new version for some new pods for canary analysis."}),"\n",(0,i.jsxs)(n.p,{children:["To address this, we have introduced the ",(0,i.jsx)(n.strong,{children:"Partial Injection Strategy"}),": By configuring ",(0,i.jsx)(n.code,{children:".spec.injectionStrategy.revision.policy: Partial"}),",\nSidecarSet will dynamically inject the latest sidecars into new pods randomly, based on the percentage specified by spec.updateStrategy.partition"]}),"\n",(0,i.jsxs)(n.p,{children:["For example, if you set ",(0,i.jsx)(n.code,{children:".spec.updateStrategy.partition: 70%"}),", then 30% of the new Pods will be injected with the latest version, while the remaining 70% will continue to use the old version. This approach automatically achieves progressive control of canary traffic without the need to manually manage version selection for specific Pods. Example configuration:"]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet \nmetadata: \n  name: sidecarset \nspec:\n  #...\n  injectionStrategy:\n    revision:\n      policy: Partial \n  updateStrategy:\n    partition: 70%\n"})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet \nmetadata: \n  name: sidecarset \nspec:\n  #...\n  injectionStrategy:\n    revision:\n      policy: Partial \n  updateStrategy:\n    partition: 70%\n"})})})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"}),": This strategy uses randomization to select the injection version, which means the injected version distribution may not be exactly as expected if the number of pods to be injected is small."]}),"\n",(0,i.jsx)(n.h3,{id:"support-k8s-128-sidecar-containers",children:"support k8s 1.28 Sidecar Containers"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.7.0"]}),"\n",(0,i.jsxs)(n.p,{children:["Kubernetes supports ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/",children:"Native Sidecar Containers"})," from version 1.28 using initContainers with ",(0,i.jsx)(n.strong,{children:"initContainers[x].restartPolicy=Always"}),".\nThe native sidecar container differ from sidecar containers in the form of normal containers in two ways:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Sidecar containers ensure that the container is ready before the main application container starts. e.g. the log collection container is ready, and the logs of the main application container startup Crash can also be collected."}),"\n",(0,i.jsx)(n.li,{children:"For job pod that runs to completion, when the application containers exit, native sidecar containers will exit on their own even if restartPolicy is Always, without blocking the completion of the pod. Sidecar container in the form of normal containers, however, will restart if the restartPolicy is Always, which will prevent the pod from completed."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"SidecarSet will also support injecting Sidecar Containers starting from v1.7.0 version as follows:"}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: test-sidecarset\nspec:\n  selector:\n    matchLabels:\n      app: sample\n  updateStrategy:\n    type: NotUpdate\n  initContainers:\n  - name: sidecar\n    image: nginx:alpine\n    restartPolicy: Always\n    lifecycle:\n      postStart:\n        exec:\n          command: ["/bin/sh", "-c", "sleep 10"]\n'})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: test-sidecarset\nspec:\n  selector:\n    matchLabels:\n      app: sample\n  updateStrategy:\n    type: NotUpdate\n  initContainers:\n  - name: sidecar\n    image: nginx:alpine\n    restartPolicy: Always\n    lifecycle:\n      postStart:\n        exec:\n          command: ["/bin/sh", "-c", "sleep 10"]\n'})})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Note:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"k8s 1.28 feature-gate SidecarContainers is off by default and needs to be actively turned on, k8s 1.29 is on by default."}),"\n",(0,i.jsxs)(n.li,{children:["If your kubernetes version < 1.28, you can use kruise ",(0,i.jsx)(n.a,{href:"/docs/user-manuals/jobsidecarterminator",children:"Job Sidecar Terminator"}),"\nand ",(0,i.jsx)(n.a,{href:"/docs/user-manuals/containerlaunchpriority",children:"Container Launch Priority"})," to solve the above problem."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Additionally, the current version only supports automatic injection of Sidecar Containers, and does not yet support in-place update capability."})}),"\n",(0,i.jsx)(n.h3,{id:"sidecarset-update-strategy",children:"sidecarset update strategy"}),"\n",(0,i.jsx)(n.p,{children:"Sidecarset not only supports the in-place update of Sidecar container, but also provides a very rich upgrade strategy."}),"\n",(0,i.jsx)(n.h4,{id:"partition",children:"partition"}),"\n",(0,i.jsxs)(n.p,{children:["Partition is the ",(0,i.jsx)(n.strong,{children:"desired number or percent of Pods in old revisions"}),", defaults to ",(0,i.jsx)(n.code,{children:"0"}),".  This field does ",(0,i.jsx)(n.strong,{children:"NOT"})," imply any update order."]}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"partition"})," is set during update:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If it is a number: ",(0,i.jsx)(n.code,{children:"(replicas - partition)"})," number of pods will be updated with the new version."]}),"\n",(0,i.jsxs)(n.li,{children:["If it is a percent: ",(0,i.jsx)(n.code,{children:"(replicas * (100% - partition))"})," number of pods will be updated with the new version."]}),"\n"]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  # ...\n  updateStrategy:\n    type: RollingUpdate\n    partition: 90\n"})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  # ...\n  updateStrategy:\n    type: RollingUpdate\n    partition: 90\n"})})})]}),"\n",(0,i.jsx)(n.p,{children:"Assuming that the number of PODs associated with this Sidecarset is 100, this upgrade will only upgrade 10 pods to latest and keep 90 pods old versions."}),"\n",(0,i.jsx)(n.h4,{id:"maxunavailable",children:"MaxUnavailable"}),"\n",(0,i.jsx)(n.p,{children:"MaxUnavailable is the maximum number of PODs that are unavailable at the same time that is guaranteed during the Posting process. The default value is 1."}),"\n",(0,i.jsx)(n.p,{children:"The user can set it to either an absolute value or a percentage (the percentage is calculated by the controller as the cardinality of the selected pod to calculate the absolute value behind one)."}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  # ...\n  updateStrategy:\n    type: RollingUpdate\n    maxUnavailable: 20%\n"})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  # ...\n  updateStrategy:\n    type: RollingUpdate\n    maxUnavailable: 20%\n"})})})]}),"\n",(0,i.jsx)(n.p,{children:"Note that maxUnavailable and partition are not necessarily related. For example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"When {matched pod}=100,partition=50,maxUnavailable=10, the controller will update 50 PODS to the new version, and only 10 PODS will be updated at the same time, until the 50 updated is completed."}),"\n",(0,i.jsx)(n.li,{children:"When {matched pod}=100,partition=80,maxUnavailable=30, the controller will update 20 PODS to the new version, because the maxUnavailable number is 30, so the 20 PODS will be updated simultaneously."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"pause",children:"Pause"}),"\n",(0,i.jsx)(n.p,{children:"A user can pause the release by setting pause to true, and the injection capability will remain for newly created, expanded PODS, while updated PODS will remain the updated version, and those that have not been updated will be paused."}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  # ...\n  updateStrategy:\n    type: RollingUpdate\n    paused: true\n"})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  # ...\n  updateStrategy:\n    type: RollingUpdate\n    paused: true\n"})})})]}),"\n",(0,i.jsx)(n.h4,{id:"selector",children:"Selector"}),"\n",(0,i.jsx)(n.p,{children:"For businesses that have Canary update requirements, this can be done through Strategy.selector filed. First: take the canary updated pods on fixed labels [canary. Release] = true, second fix the strategy.selector.MatchLabels to select the pod"}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  # ...\n  updateStrategy:\n    type: RollingUpdate\n    selector:\n      matchLabels:\n        canary.release: "true"\n'})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  # ...\n  updateStrategy:\n    type: RollingUpdate\n    selector:\n      matchLabels:\n        canary.release: "true"\n'})})})]}),"\n",(0,i.jsx)(n.h3,{id:"sidecarset-update-order",children:"sidecarset update order"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The PODs of upgrade is sorted by default to ensure the same order of multiple upgrades"}),"\n",(0,i.jsx)(n.li,{children:"The default priority is (the smaller the higher the priority)\uff1a unscheduled < scheduled, pending < unknown < running, not-ready < ready, newer pods < older pods"}),"\n",(0,i.jsx)(n.li,{children:"scatter order"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"scatter",children:"scatter"}),"\n",(0,i.jsx)(n.p,{children:"The scatter policy allows users to define the scatters of PODs that conform to certain tags throughout the publishing process.\nFor example, if a SidecarSet manages 10 PODS, if there are 3 PODS below with the tag foo=bar, and the user sets this tag in the shatter policy, then these 3 PODS will be published in the 1st, 6th, and 10th positions."}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  # ...\n  updateStrategy:\n    type: RollingUpdate\n    scatterStrategy:\n    - key: foo\n      value: bar\n"})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  # ...\n  updateStrategy:\n    type: RollingUpdate\n    scatterStrategy:\n    - key: foo\n      value: bar\n"})})})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Note: If you use Scatter, it is recommended to set only a pair of key-values for scatter. It will be easier to understand."})}),"\n",(0,i.jsx)(n.h4,{id:"priority",children:"priority"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.5.0"]}),"\n",(0,i.jsxs)(n.p,{children:["This strategy defines rules for calculating the priority of updating pods. All update candidates will be applied with the priority terms.\n",(0,i.jsx)(n.code,{children:"priority"})," can be calculated either by weight or by order."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"weight"}),": Priority is determined by the sum of weights for terms that match selector. For example,"]}),"\n"]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nspec:\n  # ...\n  updateStrategy:\n    priorityStrategy:\n      weightPriority:\n      - weight: 50\n        matchSelector:\n          matchLabels:\n            test-key: foo\n      - weight: 30\n        matchSelector:\n          matchLabels:\n            test-key: bar\n"})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nspec:\n  # ...\n  updateStrategy:\n    priorityStrategy:\n      weightPriority:\n      - weight: 50\n        matchSelector:\n          matchLabels:\n            test-key: foo\n      - weight: 30\n        matchSelector:\n          matchLabels:\n            test-key: bar\n"})})})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"order"}),': Priority will be determined by the value of the orderKey. The update candidates are sorted based on the "int" part of the value string. For example, 5 in string "5" and 10 in string "sts-10".']}),"\n"]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nspec:\n  # ...\n  updateStrategy:\n    priorityStrategy:\n      orderPriority:\n      - orderedKey: some-label-key\n"})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nspec:\n  # ...\n  updateStrategy:\n    priorityStrategy:\n      orderPriority:\n      - orderedKey: some-label-key\n"})})})]}),"\n",(0,i.jsx)(n.h3,{id:"hot-upgrade-sidecar",children:"Hot Upgrade Sidecar"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v0.9.0"]}),"\n",(0,i.jsx)(n.p,{children:"SidecarSet's in-place upgrade will stop the container of old version first and then create the container of new version. Such method is more suitable for sidecar containers that cannot affects service availability, e.g. logging collector."}),"\n",(0,i.jsx)(n.p,{children:"But for many proxy or runtime sidecar containers, e.g. Istio Envoy, this upgrade method is problematic. Envoy, as a proxy container in the Pod, proxies all the traffic, and if restarted directly, the availability of service is affected. Complex grace termination and coordination is required if one need to upgrade envoy sidecar independently of the application container. So we provide a new solution for such sidecar container upgrade."}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nmetadata:\n  name: hotupgrade-sidecarset\nspec:\n  selector:\n    matchLabels:\n      app: hotupgrade\n  containers:\n  - name: sidecar\n    image: openkruise/hotupgrade-sample:sidecarv1\n    imagePullPolicy: Always\n    lifecycle:\n      postStart:\n        exec:\n          command:\n          - /bin/sh\n          - /migrate.sh\n    upgradeStrategy:\n      upgradeType: HotUpgrade\n      hotUpgradeEmptyImage: openkruise/hotupgrade-sample:empty\n"})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: hotupgrade-sidecarset\nspec:\n  selector:\n    matchLabels:\n      app: hotupgrade\n  containers:\n  - name: sidecar\n    image: openkruise/hotupgrade-sample:sidecarv1\n    imagePullPolicy: Always\n    lifecycle:\n      postStart:\n        exec:\n          command:\n          - /bin/sh\n          - /migrate.sh\n    upgradeStrategy:\n      upgradeType: HotUpgrade\n      hotUpgradeEmptyImage: openkruise/hotupgrade-sample:empty\n"})})})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"upgradeType: HotUpgrade indicates hot upgrade for stateful sidecar container."}),"\n",(0,i.jsx)(n.li,{children:"hotUpgradeEmptyImage: when upgradeType=HotUpgrade, user needs to provide an empty container for hot upgrades. hotUpgradeEmptyImage has the same configuration as the sidecar container, for example: command, lifecycle, probe, etc, but it doesn't do anything."}),"\n",(0,i.jsx)(n.li,{children:"lifecycle.postStart: State Migration, the process completes the state migration of stateful container, which needs to be provided by the sidecar image developer."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Hot upgrade consists of the following two processes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"inject hot upgrade sidecar containers"}),"\n",(0,i.jsx)(n.li,{children:"in-place hot upgrade sidecar container"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"inject-containers",children:"Inject Containers"}),"\n",(0,i.jsx)(n.p,{children:"When the sidecar container upgradeStrategy=HotUpgrade, the SidecarSet Webhook will inject two containers into the Pod:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"{sidecarContainer.name}-1: as shown in the figure below: envoy-1, the container run the actual working sidecar container, such as envoy:1.16.0"}),"\n",(0,i.jsx)(n.li,{children:"{sidecarContainer.name}-2: as shown in the figure below: envoy-2, the container run the hot upgrade empty container, and it doesn't have to deal with any real logic, as long as it stays in place, such as empty:1.0"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"sidecarset hotupgrade_injection",src:a(44012).A+"",width:"677",height:"405"})}),"\n",(0,i.jsx)(n.h4,{id:"hot-upgrade",children:"Hot Upgrade"}),"\n",(0,i.jsx)(n.p,{children:"The SidecarSet Controller breaks down the hot upgrade process of the sidecar container into three steps:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Upgrade: upgrade the empty container to the new version of the sidecar container, such as envoy-2.Image = envoy:1.17.0"}),"\n",(0,i.jsxs)(n.li,{children:["Migration: the process completes the state migration of stateful container, which needs to be provided by the sidecar image developer. PostStartHook completes the migration of the above process.\n(",(0,i.jsx)(n.strong,{children:"Note: PostStartHook must block during the migration, and exit when migration complete."}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Reset: the step resets the old version sidecar container into empty container, such as envoy-1.Image = empty:1.0"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The above is the complete hot upgrade process. If a Pod needs to be hot upgraded several times, the above three steps can be repeated."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"sidecarset hotupgrade",src:a(74330).A+"",width:"653",height:"432"})}),"\n",(0,i.jsx)(n.h4,{id:"migration-demo",children:"Migration Demo"}),"\n",(0,i.jsxs)(n.p,{children:["The SidecarSet hot upgrade mechanism not only completes the switching between mesh containers\uff0cbut also provides a coordination mechanism for old and new versions. Yet this is only the first step of a long journey. The mesh container also needs to provide a PostStartHook script to complete the hot migration of the mesh service itself (the above Migration process), such as Envoy hot restart and Mosn lossless restart.\nTo facilitate a better understanding of the Migration process, a migration demo is provided below the kruise repository: ",(0,i.jsx)(n.a,{href:"https://github.com/openkruise/samples/tree/master/hotupgrade",children:"Migration Demo"})]}),"\n",(0,i.jsxs)(n.p,{children:["For design documentation, please refer to: ",(0,i.jsx)(n.a,{href:"https://github.com/openkruise/kruise/blob/master/docs/proposals/20210305-sidecarset-hotupgrade.md",children:"proposals sidecarset hot upgrade"})]}),"\n",(0,i.jsx)(n.p,{children:"Currently known cases that utilize the SidecarSet hot upgrade mechanism:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://help.aliyun.com/document_detail/193804.html",children:"ALIYUN ASM"})," implements lossless upgrade of Data Plane in Service Mesh."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"inject-pod-metadata-annotations",children:"Inject Pod Metadata (Annotations)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"FEATURE STATE:"})," Kruise v1.3.0"]}),"\n",(0,i.jsx)(n.p,{children:"SidecarSet support inject pod annotations, as follows:"}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(o.A,{value:"v1beta1",label:"v1beta1",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1beta1\nkind: SidecarSet\nspec:\n  containers:\n    ...\n  patchPodMetadata:\n  - annotations:\n      oom-score: \'{"log-agent": 1}\'\n      custom.example.com/sidecar-configuration: \'{"command": "/home/admin/bin/start.sh", "log-level": "3"}\'\n    patchPolicy: MergePatchJson\n  - annotations:\n      apps.kruise.io/container-launch-priority: Ordered\n    patchPolicy: Overwrite | Retain\n'})})}),(0,i.jsx)(o.A,{value:"v1alpha1",label:"v1alpha1",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nspec:\n  containers:\n    ...\n  patchPodMetadata:\n  - annotations:\n      oom-score: \'{"log-agent": 1}\'\n      custom.example.com/sidecar-configuration: \'{"command": "/home/admin/bin/start.sh", "log-level": "3"}\'\n    patchPolicy: MergePatchJson\n  - annotations:\n      apps.kruise.io/container-launch-priority: Ordered\n    patchPolicy: Overwrite | Retain\n'})})})]}),"\n",(0,i.jsx)(n.p,{children:"patchPolicy is the injected policy, as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Retain:"})," By default, if annotation[key]=value exists in the Pod, the original value of the Pod will be retained. Inject annotations[key]=value2 only if annotation[key] does not exist in the Pod."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Overwrite:"})," Corresponding to Retain, when annotation[key]=value exists in the Pod, it will be overwritten value2."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"MergePatchJson:"})," Corresponding to Overwrite, the annotations value is a json string. If the annotations[key] does not exist in the Pod, it will be injected directly. If it exists, do a json value merge.\nFor example: ",(0,i.jsx)(n.code,{children:"annotations[oom-score]='{\"main\": 2}'"})," exists in the Pod, after injection, the value json is merged into ",(0,i.jsx)(n.code,{children:'annotations[oom-score]=\'{"log-agent": 1, "main": 2}\''}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," When the patchPolicy is Overwrite and MergePatchJson, the annotations can be updated synchronously when the SidecarSet in-place update the Sidecar Container.\nHowever, if only the annotations are modified, it will not take effect. It must be in-place update together with the sidecar container image.\nWhen patchPolicy is Retain, the annotations will not be updated when the SidecarSet in-place update the Sidecar Container."]}),"\n",(0,i.jsx)(n.p,{children:"According to the above configuration, when the sidecarSet is injected into the sidecar container, it will inject Pod annotations synchronously, as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: Pod\nmetadata:\n  annotations:\n    apps.kruise.io/container-launch-priority: Ordered\n    oom-score: \'{"log-agent": 1, "main": 2}\'\n    custom.example.com/sidecar-configuration: \'{"command": "/home/admin/bin/start.sh", "log-level": "3"}\'\nname: test-pod\nspec:\n  containers:\n    ...\n'})}),"\n",(0,i.jsx)(n.h4,{id:"metadata-whitelist",children:"Metadata WhiteList"}),"\n",(0,i.jsx)(n.p,{children:"SidecarSet should not modify any configuration outside the sidecar container for security consideration. Metadata, as an important configuration of Pod, should not be modified by sidecarSet by default.\nSo if you want to use this capability, you need to first configure SidecarSet_PatchPodMetadata_WhiteList whitelist, as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kruise-configuration\n  namespace: kruise-system\ndata:\n  "SidecarSet_PatchPodMetadata_WhiteList": |\n    {\n      "rules": [\n        {\n          "selector":{\n            "matchLabels":{\n              "sidecar":"log-agent"\n            }\n          },\n          "allowedAnnotationKeyExprs": [\n            "^apps.kruise.io/container-launch-priority$",\n            "^oom-score$",\n            "^custom.example.com/sidecar-configuration$"\n          ]\n        }\n      ]\n    }\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"selector:"})," Select matching SidecarSets based on Labels, both MatchLabels and MatchExpressions are supported.\nIf not configured, it will take effect for all SidecarSets in the cluster."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"allowedAnnotationKeyExprs:"})," Whitelist of Pod annotation keys allowed to be modified, must be a regular expression."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"feature-gate",children:"Feature-gate"}),"\n",(0,i.jsx)(n.p,{children:"SidecarSet_PatchPodMetadata_WhiteList is mainly for security reasons. If the user's business cluster scenario is relatively simple,\nyou can turn off the verification of the whitelist through feature-gate."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:'$ helm install kruise https://... --set featureGates="SidecarSetPatchPodMetadataDefaultsAllowed=true"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"sidecarset-status",children:"SidecarSet Status"}),"\n",(0,i.jsx)(n.p,{children:"When upgrading sidecar containers with a SidecarSet, you can observe the process of upgrading through SidecarSet.Status"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# kubectl describe sidecarsets sidecarset-example\nName:         sidecarset-example\nKind:         SidecarSet\nStatus:\n  Matched Pods:         10  # The number of PODs injected and managed by the Sidecarset\n  Updated Pods:         5   # 5 PODs have been updated to the container version in the latest SidecarSet\n  Ready Pods:           8   # Matched Pods pod.status.condition.Ready = true number\n  Updated Ready Pods:   3   # Updated Pods && Ready Pods number\n"})}),"\n",(0,i.jsx)(n.h2,{id:"how-to-troubleshoot-sidecarset-in-place-upgrade-blocking",children:"How to troubleshoot SidecarSet in-place upgrade blocking"}),"\n",(0,i.jsxs)(n.p,{children:["The community kubernetes only allows patch pod.spec image fields, so SidecarSet upgrading sidecar containers independently can only support ",(0,i.jsx)(n.strong,{children:"image fields"}),".\nSidecarSet will not trigger in-place upgrades if non-Image fields are changed, e.g. Env, Resources, etc."]}),"\n",(0,i.jsxs)(n.p,{children:["To make it easier for you to locate similar issues, ",(0,i.jsx)(n.strong,{children:"since v1.5.0"})," kruise will report information to ",(0,i.jsx)(n.strong,{children:"pod condition"})," and ",(0,i.jsx)(n.strong,{children:"sidecarSet event"})," as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'# kubectl describe sidecarsets test-sidecarset\n  Status:\n    Collision Count:      0\n    Latest Revision:      test-sidecarset-5f6d95f777\n    Matched Pods:         1\n    Observed Generation:  2\n    Ready Pods:           1\n    Updated Pods:         0\n  Events:\n    Type    Reason             Age   From                   Message\n    ----    ------             ----  ----                   -------\n    Normal  NotUpgradablePods  63s   sidecarset-controller  SidecarSet in-place update detected 1 not upgradable pod(s) in this round, will skip them\n\n# kubectl get pods test-pod -oyaml\nstatus:\n  conditions:\n  - lastProbeTime: null\n    lastTransitionTime: "2023-09-09T11:10:17Z"\n    message: \'{"test-sidecarset":false}\'\n    reason: UpdateImmutableField\n    status: "False"\n    type: SidecarSetUpgradable\n'})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>o});var t=a(96540);const i={},s=t.createContext(i);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(s.Provider,{value:n},e.children)}},44012:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/sidecarset_hotupgrade_injection-bc68babcd84165fd3561dd2d4f5f8d9d.png"},65537:(e,n,a)=>{a.d(n,{A:()=>S});var t=a(96540),i=a(34164),s=a(65627),r=a(56347),o=a(50372),l=a(30604),c=a(11861),d=a(78749);function h(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:a}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:a,attributes:t,default:i}}=e;return{value:n,label:a,attributes:t,default:i}}))}(a);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,a])}function u(e){let{value:n,tabValues:a}=e;return a.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:a}=e;const i=(0,r.W6)(),s=function(e){let{queryString:n=!1,groupId:a}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:n,groupId:a});return[(0,l.aZ)(s),(0,t.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(i.location.search);n.set(s,e),i.replace({...i.location,search:n.toString()})}),[s,i])]}function g(e){const{defaultValue:n,queryString:a=!1,groupId:i}=e,s=p(e),[r,l]=(0,t.useState)((()=>function(e){let{defaultValue:n,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!u({value:n,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=a.find((e=>e.default))??a[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:s}))),[c,h]=m({queryString:a,groupId:i}),[g,x]=function(e){let{groupId:n}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(n),[i,s]=(0,d.Dv)(a);return[i,(0,t.useCallback)((e=>{a&&s.set(e)}),[a,s])]}({groupId:i}),j=(()=>{const e=c??g;return u({value:e,tabValues:s})?e:null})();(0,o.A)((()=>{j&&l(j)}),[j]);return{selectedValue:r,selectValue:(0,t.useCallback)((e=>{if(!u({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),h(e),x(e)}),[h,x,s]),tabValues:s}}var x=a(9136);const j={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=a(74848);function b(e){let{className:n,block:a,selectedValue:t,selectValue:r,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.a_)(),d=e=>{const n=e.currentTarget,a=l.indexOf(n),i=o[a].value;i!==t&&(c(n),r(i))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=l.indexOf(e.currentTarget)+1;n=l[a]??l[0];break}case"ArrowLeft":{const a=l.indexOf(e.currentTarget)-1;n=l[a]??l[l.length-1];break}}n?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":a},n),children:o.map((e=>{let{value:n,label:a,attributes:s}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:t===n?0:-1,"aria-selected":t===n,ref:e=>{l.push(e)},onKeyDown:h,onClick:d,...s,className:(0,i.A)("tabs__item",j.tabItem,s?.className,{"tabs__item--active":t===n}),children:a??n},n)}))})}function y(e){let{lazy:n,children:a,selectedValue:s}=e;const r=(Array.isArray(a)?a:[a]).filter(Boolean);if(n){const e=r.find((e=>e.props.value===s));return e?(0,t.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:r.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function f(e){const n=g(e);return(0,v.jsxs)("div",{className:(0,i.A)("tabs-container",j.tabList),children:[(0,v.jsx)(b,{...n,...e}),(0,v.jsx)(y,{...n,...e})]})}function S(e){const n=(0,x.A)();return(0,v.jsx)(f,{...e,children:h(e.children)},String(n))}},74330:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/sidecarset_hotupgrade-8f7325ba1f999667c60bea6d6aec32f9.png"},79329:(e,n,a)=>{a.d(n,{A:()=>r});a(96540);var t=a(34164);const i={tabItem:"tabItem_Ymn6"};var s=a(74848);function r(e){let{children:n,hidden:a,className:r}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,t.A)(i.tabItem,r),hidden:a,children:n})}}}]);