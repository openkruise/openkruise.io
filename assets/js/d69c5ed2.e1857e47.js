"use strict";(self.webpackChunkopenkruise_io=self.webpackChunkopenkruise_io||[]).push([[5273],{7556:e=>{e.exports=JSON.parse('{"permalink":"/blog/workload-classification-guidance","editUrl":"https://github.com/openkruise/openkruise.io/edit/master/blog/2019-10-10-workload-classification-guidance.md","source":"@site/blog/2019-10-10-workload-classification-guidance.md","title":"Kruise Workload Classification Guidance","description":"Kubernetes does not provide a clear guidance about which controller is the best fit for","date":"2019-10-10T00:00:00.000Z","tags":[{"inline":true,"label":"workload","permalink":"/blog/tags/workload"}],"readingTime":5.11,"hasTruncateMarker":false,"authors":[{"name":"Fei Guo","title":"Maintainer of OpenKruise","url":"https://github.com/Fei-Guo","imageURL":"https://github.com/Fei-Guo.png","key":"Fei-Guo","page":null},{"name":"Siyu Wang","title":"Maintainer of OpenKruise","url":"https://github.com/FillZpp","imageURL":"https://github.com/FillZpp.png","key":"FillZpp","page":null}],"frontMatter":{"slug":"workload-classification-guidance","title":"Kruise Workload Classification Guidance","authors":["Fei-Guo","FillZpp"],"tags":["workload"]},"unlisted":false,"prevItem":{"title":"Learning Concurrent Reconciling","permalink":"/blog/learning-concurrent-reconciling"}}')},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var i=t(96540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},32174:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var i=t(7556),o=t(74848),s=t(28453);const r={slug:"workload-classification-guidance",title:"Kruise Workload Classification Guidance",authors:["Fei-Guo","FillZpp"],tags:["workload"]},l=void 0,a={authorsImageUrls:[void 0,void 0]},d=[{value:"Controller Name Convention",id:"controller-name-convention",level:3},{value:"Fixed Pod Name",id:"fixed-pod-name",level:3},{value:"Summary",id:"summary",level:3}];function c(e){const n={a:"a",code:"code",h3:"h3",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["Kubernetes does not provide a clear guidance about which controller is the best fit for\na user application. Sometimes, this does not seem to be a big problem if users understand\nboth the application and workload well. For example, users usually know when to choose\n",(0,o.jsx)(n.code,{children:"Job/CronJob"})," or ",(0,o.jsx)(n.code,{children:"DaemonSet"})," since the concepts of these workload are straightforward -\nthe former is designed for temporal batch style applications and the latter is suitable\nfor long running Pod which is distributed in every node. On the other hand, the usage\nboundary between ",(0,o.jsx)(n.code,{children:"Deployment"})," and ",(0,o.jsx)(n.code,{children:"StatefulSet"})," is vague. An application managed by\na ",(0,o.jsx)(n.code,{children:"Deployment"})," conceptually can be managed by a ",(0,o.jsx)(n.code,{children:"StatefulSet"})," as well, the opposite may\nalso apply as long as the Pod ",(0,o.jsx)(n.code,{children:"OrderedReady"})," capability of ",(0,o.jsx)(n.code,{children:"StatefulSet"})," is not mandatory.\nFurthermore, as more and more customized controllers/operators become available in Kubernetes\ncommunity, finding suitable controller can be a nonnegligible user problem especially\nwhen some controllers have functional overlaps."]}),"\n",(0,o.jsx)(n.p,{children:"Kruise attempts to mitigate the problem from two aspects:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Carefully design the new controllers in the Kruise suite to avoid unnecessary functional\nduplications that may confuse users."}),"\n",(0,o.jsx)(n.li,{children:"Establish a classification mechanism for existing workload controllers so that user\ncan more easily understand the use cases of them. We will elaborate this more in this\npost. The first and most intuitive criterion for classification is the controller name."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"controller-name-convention",children:"Controller Name Convention"}),"\n",(0,o.jsx)(n.p,{children:"An easily understandable controller name can certainly help adoption. After consulting\nwith many internal/external Kubernetes users, we decide to use the following naming\nconventions in Kruise. Note that these conventions are not contradicted with the controller\nnames used in upstream controllers."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Set"})," -suffix names: This type of controller manages Pods directly. Examples\ninclude ",(0,o.jsx)(n.code,{children:"CloneSet"}),", ",(0,o.jsx)(n.code,{children:"ReplicaSet"})," and ",(0,o.jsx)(n.code,{children:"SidecarSet"}),". It supports\nvarious depolyment/rollout strategies in Pod level."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Deployment"})," -suffix names: This type of controller does not manage Pods\ndirectly. Instead, it manages one or many ",(0,o.jsx)(n.strong,{children:"Set"})," -suffix workload instances which are\ncreated on behalf of one application. The controller can provide capabilities\nto orchestrate the deployment/rollout of multiple instances. For example, ",(0,o.jsx)(n.code,{children:"Deployment"}),"\nmanages ",(0,o.jsx)(n.code,{children:"ReplicaSet"})," and provides rollout capability which is not available in ",(0,o.jsx)(n.code,{children:"ReplicaSet"}),".\n",(0,o.jsx)(n.code,{children:"UnitedDeployment"})," (planned in ",(0,o.jsx)(n.a,{href:"https://github.com/openkruise/kruise/projects",children:"M3 release"}),")\nmanages multiple ",(0,o.jsx)(n.code,{children:"StatefulSet"})," created in respect of multiple domains\n(i.e., fault domains) within one cluster."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Job"})," -suffix names: This type of controller manages batch style applications with\ndifferent depolyment/rollout strategies. For example, ",(0,o.jsx)(n.code,{children:"BroadcastJob"})," distributes a\njob style Pod to every node in the cluster."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Set"}),", ",(0,o.jsx)(n.strong,{children:"Deployment"})," and ",(0,o.jsx)(n.strong,{children:"Job"})," are widely adopted terms in Kubernetes community.\nKruise leverages them with certain extensions."]}),"\n",(0,o.jsxs)(n.p,{children:["Can we further distinguish controllers with the same name suffix? Normally the string prior to\nthe suffix should be self-explainable, but in many cases it is hard to find a right word to\ndescribe what the controller does. Check to see how ",(0,o.jsx)(n.code,{children:"StatefulSet"})," is originated in\nthis ",(0,o.jsx)(n.a,{href:"https://github.com/kubernetes/kubernetes/issues/27430",children:"thread"}),". It takes four\nmonths for community to decide to use the name ",(0,o.jsx)(n.code,{children:"StatefulSet"})," to replace the original\nname ",(0,o.jsx)(n.code,{children:"PetSet"})," although the new name still confuse people by looking\nat its API documentation. This example showcases that sometimes a well-thought-out name\nmay not be helpful to identify controller. Again, Kruise does not plan to resolve\nthis problem. As an incremental effort, Kruise considers the following criterion to help classify\n",(0,o.jsx)(n.strong,{children:"Set"})," -suffix controllers."]}),"\n",(0,o.jsx)(n.h3,{id:"fixed-pod-name",children:"Fixed Pod Name"}),"\n",(0,o.jsxs)(n.p,{children:["One unique property of ",(0,o.jsx)(n.code,{children:"StatefulSet"})," is that it maintains consistent identities for\nPod network and storage. Essentially, this is done by fixing Pod names.\nPod name can identify both network and storage since it is part of DNS record and\ncan be used to name Pod volume claim. Why is this property needed given that all Pods in\n",(0,o.jsx)(n.code,{children:"StatefulSet"})," are created from the same Pod template?\nA well known use case is to manage distributed coordination server application such as\netcd or Zookeeper. This type of application requires the cluster member\n(i.e., the Pod) to access the same data (in Pod volume) whenever a member is\nreconstructed upon failure, in order to function correctly. To differentiate the term\n",(0,o.jsx)(n.code,{children:"State"})," in ",(0,o.jsx)(n.code,{children:"StatefulSet"})," from the same term used in other computer science areas,\nI'd like to associate ",(0,o.jsx)(n.code,{children:"State"})," with Pod name in this document. That being said, controllers\nlike ",(0,o.jsx)(n.code,{children:"ReplicaSet"})," and ",(0,o.jsx)(n.code,{children:"DaemonSet"})," are ",(0,o.jsx)(n.code,{children:"Stateless"})," since they don't require to reuse the\nold Pod name when a Pod is recreated."]}),"\n",(0,o.jsxs)(n.p,{children:["Supporting ",(0,o.jsx)(n.code,{children:"Stateful"})," does lead to inflexibility for controller. ",(0,o.jsx)(n.code,{children:"StatefulSet"})," relies on ordinal\nnumbers to realize fixing Pod names. The workload rollout and scaling\nhas to be done in a strict order. As a consequence, some useful enhancements to ",(0,o.jsx)(n.code,{children:"StatefulSet"}),"\nbecome impossible. For example,"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Selective Pod upgrade and Pod deletion (when scale in). These features can be helpful\nwhen Pods are spread across different regions or fault domains."}),"\n",(0,o.jsxs)(n.li,{children:["The ability of taking control over existing Pods with arbitrary names. There are\ncases where Pod creation is done by one controller but Pod lifecycle management\nis done by another controller (e.g., ",(0,o.jsx)(n.code,{children:"StatefulSet"}),")."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["We found that many containerized applications do not require the ",(0,o.jsx)(n.code,{children:"Stateful"})," property\nof fixing Pod names, and ",(0,o.jsx)(n.code,{children:"StatefulSet"})," is hard to be extended for those\napplications in many cases. To fill the gap, Kruise has released a new controller\ncalled ",(0,o.jsx)(n.code,{children:"CloneSet"})," to manage the ",(0,o.jsx)(n.code,{children:"Stateless"})," applications. In a nutshell, ",(0,o.jsx)(n.code,{children:"CloneSet"}),"\nprovides PVC support and enriched rollout and management capabilities.\nThe following table roughly compares Advanced StatefulSet and CloneSet in a few aspects."]}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Features"}),(0,o.jsx)(n.th,{style:{textAlign:"center"},children:"Advanced StatefulSet"}),(0,o.jsx)(n.th,{style:{textAlign:"center"},children:"CloneSet"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"PVC"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"Yes"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"Yes"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Pod name"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"Ordered"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"Random"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Inplace upgrade"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"Yes"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"Yes"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Max unavailable"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"Yes"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"Yes"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Selective deletion"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"No"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"Yes"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Selective upgrade"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"No"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"Yes"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Change Pod ownership"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"No"}),(0,o.jsx)(n.td,{style:{textAlign:"center"},children:"Yes"})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:["Now, a clear recommendation to Kruise users is if your applications require fixed Pod names (identities for Pod network and storage), you can start with ",(0,o.jsx)(n.code,{children:"Advanced StatefulSet"}),".\nOtherwise, ",(0,o.jsx)(n.code,{children:"CloneSet"})," is the primary choice of ",(0,o.jsx)(n.strong,{children:"Set"})," -suffix controllers (if ",(0,o.jsx)(n.code,{children:"DaemonSet"})," is not\napplicable)."]}),"\n",(0,o.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"Kruise aims to provide intuitive names for new controllers. As a supplement, this post\nprovides additional guidance for Kruise users to pick the right controller for their\napplications. Hope it helps!"})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);