"use strict";(self.webpackChunkopenkruise_io=self.webpackChunkopenkruise_io||[]).push([[8070],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var i=s(96540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}},85585:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"faq","title":"FAQ","description":"Installation and Uninstallation","source":"@site/docs/faq.md","sourceDirName":".","slug":"/faq","permalink":"/docs/next/faq","draft":false,"unlisted":false,"editUrl":"https://github.com/openkruise/openkruise.io/edit/master/docs/faq.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Kumar","lastUpdatedAt":1754378959000,"frontMatter":{"title":"FAQ"},"sidebar":"docs","previous":{"title":"Kustomize Schema Generator","permalink":"/docs/next/cli-tool/kustomize-schema-generator"}}');var r=s(74848),t=s(28453);const o={title:"FAQ"},l=void 0,a={},d=[{value:"Installation and Uninstallation",id:"installation-and-uninstallation",level:2},{value:"Uninstall Protection",id:"uninstall-protection",level:3},{value:"Q: Get error <code>job kruise-finalizer failed: BackoffLimitExceeded</code> when Helm uninstall Kruise 1.7.3 or above",id:"q-get-error-job-kruise-finalizer-failed-backofflimitexceeded-when-helm-uninstall-kruise-173-or-above",level:4},{value:"Pod Creation/Update Errors",id:"pod-creationupdate-errors",level:2},{value:"<strong>Q</strong>: The operation on the pod fails and the following error occurs. What is the reason?",id:"q-the-operation-on-the-pod-fails-and-the-following-error-occurs-what-is-the-reason",level:4},{value:"Workload Selection and Migration",id:"workload-selection-and-migration",level:2},{value:"<strong>Q</strong>: When should I use CloneSet instead of Deployment?",id:"q-when-should-i-use-cloneset-instead-of-deployment",level:4},{value:"<strong>Q</strong>: How do I migrate from Deployment to CloneSet?",id:"q-how-do-i-migrate-from-deployment-to-cloneset",level:4},{value:"<strong>Q</strong>: What&#39;s the difference between Advanced StatefulSet and native StatefulSet?",id:"q-whats-the-difference-between-advanced-statefulset-and-native-statefulset",level:4},{value:"Performance and Scaling",id:"performance-and-scaling",level:2},{value:"<strong>Q</strong>: How does in-place update improve performance?",id:"q-how-does-in-place-update-improve-performance",level:4},{value:"<strong>Q</strong>: What are the limitations of in-place updates?",id:"q-what-are-the-limitations-of-in-place-updates",level:4},{value:"<strong>Q</strong>: How do I optimize OpenKruise performance in large clusters?",id:"q-how-do-i-optimize-openkruise-performance-in-large-clusters",level:4},{value:"SidecarSet and Container Management",id:"sidecarset-and-container-management",level:2},{value:"<strong>Q</strong>: How do I inject sidecars into existing pods?",id:"q-how-do-i-inject-sidecars-into-existing-pods",level:4},{value:"<strong>Q</strong>: Can I update sidecar containers without affecting main containers?",id:"q-can-i-update-sidecar-containers-without-affecting-main-containers",level:4},{value:"<strong>Q</strong>: How do I handle sidecar container dependencies?",id:"q-how-do-i-handle-sidecar-container-dependencies",level:4},{value:"Security and RBAC",id:"security-and-rbac",level:2},{value:"<strong>Q</strong>: What RBAC permissions does OpenKruise need?",id:"q-what-rbac-permissions-does-openkruise-need",level:4},{value:"<strong>Q</strong>: How do I secure OpenKruise in production?",id:"q-how-do-i-secure-openkruise-in-production",level:4},{value:"<strong>Q</strong>: Can I run OpenKruise in air-gapped environments?",id:"q-can-i-run-openkruise-in-air-gapped-environments",level:4},{value:"Monitoring and Observability",id:"monitoring-and-observability",level:2},{value:"<strong>Q</strong>: How do I monitor OpenKruise workloads?",id:"q-how-do-i-monitor-openkruise-workloads",level:4},{value:"<strong>Q</strong>: What metrics should I monitor for OpenKruise?",id:"q-what-metrics-should-i-monitor-for-openkruise",level:4},{value:"Troubleshooting and Debugging",id:"troubleshooting-and-debugging",level:2},{value:"<strong>Q</strong>: How do I debug CloneSet update issues?",id:"q-how-do-i-debug-cloneset-update-issues",level:4},{value:"<strong>Q</strong>: Why are my pods stuck in PreparingUpdate state?",id:"q-why-are-my-pods-stuck-in-preparingupdate-state",level:4},{value:"Integration and Ecosystem",id:"integration-and-ecosystem",level:2},{value:"<strong>Q</strong>: Does OpenKruise work with GitOps tools like ArgoCD?",id:"q-does-openkruise-work-with-gitops-tools-like-argocd",level:4},{value:"<strong>Q</strong>: Can I use OpenKruise with service mesh (Istio/Linkerd)?",id:"q-can-i-use-openkruise-with-service-mesh-istiolinkerd",level:4},{value:"<strong>Q</strong>: How do I use OpenKruise with HPA/VPA?",id:"q-how-do-i-use-openkruise-with-hpavpa",level:4},{value:"Best Practices and Recommendations",id:"best-practices-and-recommendations",level:2},{value:"<strong>Q</strong>: What are the best practices for production deployments?",id:"q-what-are-the-best-practices-for-production-deployments",level:4},{value:"<strong>Q</strong>: How do I plan capacity for OpenKruise?",id:"q-how-do-i-plan-capacity-for-openkruise",level:4}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"installation-and-uninstallation",children:"Installation and Uninstallation"}),"\n",(0,r.jsx)(n.h3,{id:"uninstall-protection",children:"Uninstall Protection"}),"\n",(0,r.jsxs)(n.h4,{id:"q-get-error-job-kruise-finalizer-failed-backofflimitexceeded-when-helm-uninstall-kruise-173-or-above",children:["Q: Get error ",(0,r.jsx)(n.code,{children:"job kruise-finalizer failed: BackoffLimitExceeded"})," when Helm uninstall Kruise 1.7.3 or above"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Uninstallation will lead to the deletion of all resources under Kruise, including webhook configurations, services,\nnamespace, CRDs, CRs, and all Pods under Kruise workloads. Please proceed with caution!"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"A: Since 1.7.3, Kruise installed via Helm will automatically detect the existence of Kruise CRs during uninstallation\nusing a pre-delete hook. If any CRs exist, the uninstall process will be blocked. You need to manually clean up the\nKruise CRs before you can uninstall Kruise."}),"\n",(0,r.jsx)(n.p,{children:"You can check which Kruise CRs are blocking the uninstallation in the cluster as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"kubectl get clone -A \nkubectl get asts -A \nkubectl get ads -A\n"})}),"\n",(0,r.jsx)(n.p,{children:"If these Kruise workloads and their managed Pods still need to be retained, please carefully evaluate the uninstallation\noperation for Kruise."}),"\n",(0,r.jsx)(n.h2,{id:"pod-creationupdate-errors",children:"Pod Creation/Update Errors"}),"\n",(0,r.jsxs)(n.h4,{id:"q-the-operation-on-the-pod-fails-and-the-following-error-occurs-what-is-the-reason",children:[(0,r.jsx)(n.strong,{children:"Q"}),": The operation on the pod fails and the following error occurs. What is the reason?"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'Error from server (InternalError): Internal error occurred: failed calling webhook "vpod.kb.io": failed to call webhook: Post "https://kruise-webhook-service.kruise-system.svc:443/validate-pod?timeout=10s": no endpoints available for service "kruise-webhook-service"\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Check whether the kruise-controller-manager pod under kruise-system is in a healthy state. When it is abnormal (\npending/not ready/no instance, etc.), the corresponding validate webhook will not be able to find the corresponding\nendpoints, causing the verification to fail, and then the pod operation will fail.\nThe solution is to restore the kruise-controller-manager pod to a healthy state according to the prompts; or temporarily\ndelete the validatingwebhookconfiguration named ",(0,r.jsx)(n.code,{children:"kruise-validating-webhook-configuration"})," in the cluster, and then\nre-create it after the cluster is normal."]}),"\n",(0,r.jsx)(n.h2,{id:"workload-selection-and-migration",children:"Workload Selection and Migration"}),"\n",(0,r.jsxs)(n.h4,{id:"q-when-should-i-use-cloneset-instead-of-deployment",children:[(0,r.jsx)(n.strong,{children:"Q"}),": When should I use CloneSet instead of Deployment?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Use CloneSet when you need:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"In-place updates"})," for faster rollouts with minimal disruption"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Advanced scaling strategies"})," like specified pod deletion"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"PVC support"})," for stateless workloads that need persistent storage"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"More granular update control"})," with partition and maxUnavailable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better rollback capabilities"})," with revision management"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"CloneSet is ideal for large-scale stateless applications where update speed and control are critical."}),"\n",(0,r.jsxs)(n.h4,{id:"q-how-do-i-migrate-from-deployment-to-cloneset",children:[(0,r.jsx)(n.strong,{children:"Q"}),": How do I migrate from Deployment to CloneSet?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Use the ",(0,r.jsx)(n.a,{href:"https://github.com/openkruise/kruise-tools?tab=readme-ov-file#migrate",children:"kruise-tools"})," command for migration."]}),"\n",(0,r.jsxs)(n.h4,{id:"q-whats-the-difference-between-advanced-statefulset-and-native-statefulset",children:[(0,r.jsx)(n.strong,{children:"Q"}),": What's the difference between Advanced StatefulSet and native StatefulSet?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Advanced StatefulSet provides additional features:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"In-place updates"})," for containers and metadata"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parallel pod management"})," for faster scaling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Selective pod updates"})," with partition support"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom pod deletion"})," strategies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enhanced lifecycle management"})," with readiness gates"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Use Advanced StatefulSet when you need more control over stateful workload operations."}),"\n",(0,r.jsx)(n.h2,{id:"performance-and-scaling",children:"Performance and Scaling"}),"\n",(0,r.jsxs)(n.h4,{id:"q-how-does-in-place-update-improve-performance",children:[(0,r.jsx)(n.strong,{children:"Q"}),": How does in-place update improve performance?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": In-place updates provide significant benefits:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Faster rollouts"}),": Only container restart, no pod recreation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resource efficiency"}),": No scheduler overhead or IP changes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reduced disruption"}),": Maintains pod identity and network connections"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lower latency"}),": No CNI/CSI re-initialization"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This is especially beneficial for large-scale deployments where pod recreation overhead becomes significant."}),"\n",(0,r.jsxs)(n.h4,{id:"q-what-are-the-limitations-of-in-place-updates",children:[(0,r.jsx)(n.strong,{children:"Q"}),": What are the limitations of in-place updates?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": In-place updates have some constraints:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limited field support"}),": Currently supports container image and environment variables from metadata"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime compatibility"}),": Requires compatible container runtime"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rollback complexity"}),": May need careful planning for rollbacks"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Note: Since v1.8.0, in-place updates also support modifying container resources (CPU/Memory) when the ",(0,r.jsx)(n.code,{children:"InPlaceWorkloadVerticalScaling"})," feature gate is enabled."]}),"\n",(0,r.jsxs)(n.h4,{id:"q-how-do-i-optimize-openkruise-performance-in-large-clusters",children:[(0,r.jsx)(n.strong,{children:"Q"}),": How do I optimize OpenKruise performance in large clusters?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Follow these optimization practices:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tune controller concurrency"}),": Adjust ",(0,r.jsx)(n.code,{children:"--concurrent-cloneset-syncs"})," and similar flags"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configure resource limits"}),": Set appropriate CPU/memory for kruise-manager"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use feature gates"}),": Disable unused features to reduce overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitor metrics"}),": Watch controller queue depth and reconciliation time"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Batch operations"}),": Use partition updates for large-scale changes"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Example performance tuning\nhelm upgrade kruise openkruise/kruise \\\n  --set manager.resources.limits.cpu=500m \\\n  --set manager.resources.limits.memory=1Gi \\\n  --set featureGates="UnusedFeature=false"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"sidecarset-and-container-management",children:"SidecarSet and Container Management"}),"\n",(0,r.jsxs)(n.h4,{id:"q-how-do-i-inject-sidecars-into-existing-pods",children:[(0,r.jsx)(n.strong,{children:"Q"}),": How do I inject sidecars into existing pods?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": SidecarSet automatically injects sidecars into matching pods:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Create a SidecarSet"})," with appropriate selectors"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"New pods"})," will get sidecars injected immediately during creation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Existing pods"})," can be updated using SidecarSet's in-place update capabilities"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use hot upgrade"})," for stateful sidecar containers that require zero-downtime updates"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: logging-sidecar\nspec:\n  selector:\n    matchLabels:\n      app: my-app\n  containers:\n  - name: logging-agent\n    image: fluent/fluent-bit:latest\n    command: ["fluent-bit", "-c", "/fluent-bit/etc/fluent-bit.conf"]\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"q-can-i-update-sidecar-containers-without-affecting-main-containers",children:[(0,r.jsx)(n.strong,{children:"Q"}),": Can I update sidecar containers without affecting main containers?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Yes, SidecarSet supports ",(0,r.jsx)(n.strong,{children:"hot upgrade"})," for in-place sidecar updates:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Independent updates"}),": Sidecar updates don't restart main containers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rolling updates"}),": Controlled rollout with partition support"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Image updates"}),": Change sidecar images without pod recreation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configuration updates"}),": Update sidecar env vars and volumes"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This is particularly useful for logging agents, monitoring sidecars, and service mesh proxies."}),"\n",(0,r.jsxs)(n.h4,{id:"q-how-do-i-handle-sidecar-container-dependencies",children:[(0,r.jsx)(n.strong,{children:"Q"}),": How do I handle sidecar container dependencies?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Use SidecarSet's container lifecycle management:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Init containers"}),": Use ",(0,r.jsx)(n.code,{children:"initContainers"})," for setup dependencies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Container ordering"}),": Configure injection order with ",(0,r.jsx)(n.code,{children:"podInjectPolicy"})," (BeforeAppContainer/AfterAppContainer)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shared volumes"}),": Use volume mounts for inter-container communication"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Environment sharing"}),": Use ",(0,r.jsx)(n.code,{children:"transferEnv"})," to share environment variables"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"security-and-rbac",children:"Security and RBAC"}),"\n",(0,r.jsxs)(n.h4,{id:"q-what-rbac-permissions-does-openkruise-need",children:[(0,r.jsx)(n.strong,{children:"Q"}),": What RBAC permissions does OpenKruise need?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": OpenKruise requires permissions for:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Core resources"}),": Pods, Services, ConfigMaps, Secrets"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Workload resources"}),": Deployments, StatefulSets, DaemonSets"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom resources"}),": All Kruise CRDs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Webhook management"}),": ValidatingWebhookConfiguration, MutatingWebhookConfiguration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node access"}),": For kruise-daemon operations"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The Helm chart automatically creates appropriate RBAC resources. For custom installations, refer to the RBAC manifests in the charts."}),"\n",(0,r.jsxs)(n.h4,{id:"q-how-do-i-secure-openkruise-in-production",children:[(0,r.jsx)(n.strong,{children:"Q"}),": How do I secure OpenKruise in production?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Follow these security best practices:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Network policies"}),": Restrict kruise-system namespace traffic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pod security"}),": Use Pod Security Standards/Policies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RBAC"}),": Apply principle of least privilege"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TLS certificates"}),": Use cert-manager for webhook certificates"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Image security"}),": Scan OpenKruise images for vulnerabilities"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Audit logging"}),": Enable Kubernetes audit logs for Kruise operations"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"# Example network policy\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: kruise-system-policy\n  namespace: kruise-system\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          name: kube-system\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"q-can-i-run-openkruise-in-air-gapped-environments",children:[(0,r.jsx)(n.strong,{children:"Q"}),": Can I run OpenKruise in air-gapped environments?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Yes, OpenKruise supports air-gapped deployments:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mirror images"}),": Copy OpenKruise images to private registry"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Update image references"}),": Modify Helm values to use private registry"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bundle charts"}),": Download Helm charts for offline installation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configure image pull secrets"}),": Set up authentication for private registry"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Example air-gapped installation\nhelm install kruise ./kruise-chart \\\n  --set manager.image.repository=private-registry.com/kruise-manager \\\n  --set daemon.image.repository=private-registry.com/kruise-daemon \\\n  --set imagePullSecrets[0].name=private-registry-secret\n"})}),"\n",(0,r.jsx)(n.h2,{id:"monitoring-and-observability",children:"Monitoring and Observability"}),"\n",(0,r.jsxs)(n.h4,{id:"q-how-do-i-monitor-openkruise-workloads",children:[(0,r.jsx)(n.strong,{children:"Q"}),": How do I monitor OpenKruise workloads?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": OpenKruise provides comprehensive monitoring capabilities:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Built-in metrics"}),": Prometheus metrics on port 8080"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Kruise State Metrics"}),": Extended metrics for workload states"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Structured logging"}),": JSON format logs for better parsing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom dashboards"}),": Grafana dashboards for visualization"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Install kruise-state-metrics\nhelm install kruise-state-metrics openkruise/kruise-state-metrics\n\n# Access metrics\nkubectl port-forward -n kruise-system svc/kruise-controller-manager 8080:8080\ncurl localhost:8080/metrics\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"q-what-metrics-should-i-monitor-for-openkruise",children:[(0,r.jsx)(n.strong,{children:"Q"}),": What metrics should I monitor for OpenKruise?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Key metrics to monitor:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Controller performance"}),": ",(0,r.jsx)(n.code,{children:"controller_runtime_reconcile_time_seconds"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Workqueue depth"}),": ",(0,r.jsx)(n.code,{children:"workqueue_depth"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Webhook latency"}),": ",(0,r.jsx)(n.code,{children:"controller_runtime_webhook_latency_seconds"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error rates"}),": ",(0,r.jsx)(n.code,{children:"controller_runtime_reconcile_errors_total"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resource states"}),": Custom metrics from kruise-state-metrics"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For detailed monitoring guidance, see the ",(0,r.jsx)(n.a,{href:"https://openkruise.io/docs/operator-manuals/troubleshooting",children:"troubleshooting documentation"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting-and-debugging",children:"Troubleshooting and Debugging"}),"\n",(0,r.jsxs)(n.h4,{id:"q-how-do-i-debug-cloneset-update-issues",children:[(0,r.jsx)(n.strong,{children:"Q"}),": How do I debug CloneSet update issues?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Follow this debugging approach:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check CloneSet status"}),": ",(0,r.jsx)(n.code,{children:"kubectl describe cloneset <name>"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Examine pod events"}),": ",(0,r.jsx)(n.code,{children:"kubectl describe pod <pod-name>"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Review controller logs"}),": ",(0,r.jsx)(n.code,{children:"kubectl logs -n kruise-system deployment/kruise-controller-manager"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Verify update strategy"}),": Check partition and maxUnavailable settings"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check resource constraints"}),": Ensure sufficient cluster resources"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Common issues include resource limits, image pull failures, and readiness probe timeouts."}),"\n",(0,r.jsxs)(n.h4,{id:"q-why-are-my-pods-stuck-in-preparingupdate-state",children:[(0,r.jsx)(n.strong,{children:"Q"}),": Why are my pods stuck in PreparingUpdate state?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Pods in PreparingUpdate state typically indicate:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Image pre-download"}),": ImagePullJob is downloading new images (when ",(0,r.jsx)(n.code,{children:"PreDownloadImageForInPlaceUpdate"})," feature gate is enabled)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Readiness gates"}),": Custom readiness conditions not met"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Update constraints"}),": Partition or PodUnavailableBudget blocking updates"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Check the workload status and events to identify the specific cause. Verify that readiness conditions are properly configured and update constraints allow the pod to proceed."}),"\n",(0,r.jsx)(n.h2,{id:"integration-and-ecosystem",children:"Integration and Ecosystem"}),"\n",(0,r.jsxs)(n.h4,{id:"q-does-openkruise-work-with-gitops-tools-like-argocd",children:[(0,r.jsx)(n.strong,{children:"Q"}),": Does OpenKruise work with GitOps tools like ArgoCD?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Yes, OpenKruise is fully compatible with GitOps workflows:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ArgoCD"}),": Supports Kruise CRDs with proper health checks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flux"}),": Works with Kruise resources using standard Kubernetes APIs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tekton/Jenkins"}),": Can deploy Kruise workloads in CI/CD pipelines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Helm"}),": Native Helm chart support for templating"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For detailed ArgoCD integration, see the ",(0,r.jsx)(n.a,{href:"https://openkruise.io/docs/best-practices/gitops-with-kruise",children:"ArgoCD integration best practices"}),"."]}),"\n",(0,r.jsxs)(n.h4,{id:"q-can-i-use-openkruise-with-service-mesh-istiolinkerd",children:[(0,r.jsx)(n.strong,{children:"Q"}),": Can I use OpenKruise with service mesh (Istio/Linkerd)?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": OpenKruise works seamlessly with service mesh:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic injection"}),": SidecarSet can inject mesh sidecars"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Traffic management"}),": In-place updates maintain service mesh connectivity"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Observability"}),": Mesh metrics work with Kruise workloads"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Security policies"}),": mTLS and security policies apply normally"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Use SidecarSet for consistent sidecar injection across workloads."}),"\n",(0,r.jsxs)(n.h4,{id:"q-how-do-i-use-openkruise-with-hpavpa",children:[(0,r.jsx)(n.strong,{children:"Q"}),": How do I use OpenKruise with HPA/VPA?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": OpenKruise workloads support standard Kubernetes autoscaling:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"HPA"}),": Works with CloneSet, Advanced StatefulSet, and Advanced DaemonSet"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"VPA"}),": Supports vertical scaling recommendations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom metrics"}),": Use custom metrics for advanced scaling decisions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scaling policies"}),": Configure scaling behavior for smooth operations"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For comprehensive autoscaling strategies, see the ",(0,r.jsx)(n.a,{href:"https://openkruise.io/docs/best-practices/elastic-deployment",children:"autoscaling best practices"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"apiVersion: autoscaling/v2beta2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: cloneset-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps.kruise.io/v1alpha1\n    kind: CloneSet\n    name: my-cloneset\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      targetAverageUtilization: 70\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-and-recommendations",children:"Best Practices and Recommendations"}),"\n",(0,r.jsxs)(n.h4,{id:"q-what-are-the-best-practices-for-production-deployments",children:[(0,r.jsx)(n.strong,{children:"Q"}),": What are the best practices for production deployments?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Follow these production guidelines:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Start small"}),": Begin with non-critical workloads"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test thoroughly"}),": Validate in staging environments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitor closely"}),": Set up comprehensive monitoring and alerting"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Plan rollbacks"}),": Have rollback procedures ready"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use feature gates"}),": Enable features gradually"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Regular updates"}),": Keep OpenKruise updated for security and features"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Documentation"}),": Document your Kruise configurations and procedures"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For detailed production deployment guidance, see the ",(0,r.jsx)(n.a,{href:"https://openkruise.io/docs/operator-manuals/availability",children:"high availability operations manual"}),"."]}),"\n",(0,r.jsxs)(n.h4,{id:"q-how-do-i-plan-capacity-for-openkruise",children:[(0,r.jsx)(n.strong,{children:"Q"}),": How do I plan capacity for OpenKruise?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Consider these capacity factors:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Controller resources"}),": Scale kruise-manager based on workload count"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Webhook latency"}),": Monitor and tune webhook timeout settings"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"etcd load"}),": Large-scale deployments increase etcd pressure"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Network bandwidth"}),": In-place updates reduce network usage"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Storage"}),": Consider PVC requirements for CloneSet workloads"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Start with default resources and scale based on monitoring data."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);