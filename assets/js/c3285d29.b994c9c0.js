"use strict";(globalThis.webpackChunkopenkruise_io=globalThis.webpackChunkopenkruise_io||[]).push([[8447],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var o=i(96540);const t={},s=o.createContext(t);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(s.Provider,{value:n},e.children)}},44904:e=>{e.exports=JSON.parse('{"permalink":"/blog/openkruise-1.3","editUrl":"https://github.com/openkruise/openkruise.io/edit/master/blog/2022-10-07-release-1.3.md","source":"@site/blog/2022-10-07-release-1.3.md","title":"OpenKruise v1.3, New Custom Pod Probe Capabilities and Significant Performance Improvements for Large-Scale Clusters","description":"We\u2019re pleased to announce the release of OpenKruise 1.3, which is a CNCF Sandbox level project.","date":"2022-10-07T00:00:00.000Z","tags":[{"inline":true,"label":"release","permalink":"/blog/tags/release"}],"readingTime":9.17,"hasTruncateMarker":false,"authors":[{"name":"Mingshan Zhao","title":"Member of OpenKruise","url":"https://github.com/zmberg","imageURL":"https://github.com/zmberg.png","key":"zmberg","page":null}],"frontMatter":{"slug":"openkruise-1.3","title":"OpenKruise v1.3, New Custom Pod Probe Capabilities and Significant Performance Improvements for Large-Scale Clusters","authors":["zmberg"],"tags":["release"]},"unlisted":false,"prevItem":{"title":"OpenKruise V1.4 Release, New Job Sidecar Terminator Capability","permalink":"/blog/openkruise-1.4"},"nextItem":{"title":"OpenKruise v1.2, new PersistentPodState feature to achieve IP retention","permalink":"/blog/openkruise-1.2"}}')},85709:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var o=i(44904),t=i(74848),s=i(28453);const r={slug:"openkruise-1.3",title:"OpenKruise v1.3, New Custom Pod Probe Capabilities and Significant Performance Improvements for Large-Scale Clusters",authors:["zmberg"],tags:["release"]},a=void 0,l={authorsImageUrls:[void 0]},c=[{value:"What&#39;s new?",id:"whats-new",level:2},{value:"1. New CRD and Controller: PodProbeMarker",id:"1-new-crd-and-controller-podprobemarker",level:3},{value:"2. Performance optimization: significant performance improvements for large-scale clusters",id:"2-performance-optimization-significant-performance-improvements-for-large-scale-clusters",level:3},{value:"3. SidecarSet support inject specific historical version",id:"3-sidecarset-support-inject-specific-historical-version",level:3},{value:"select revision via ControllerRevision name",id:"select-revision-via-controllerrevision-name",level:4},{value:"select revision via custom version label",id:"select-revision-via-custom-version-label",level:4},{value:"4. SidecarSet support inject pod annotations",id:"4-sidecarset-support-inject-pod-annotations",level:3},{value:"5. Advanced DaemonSet support pre-downloading image for update",id:"5-advanced-daemonset-support-pre-downloading-image-for-update",level:3},{value:"6. CloneSet Scaling with PreparingDelete",id:"6-cloneset-scaling-with-preparingdelete",level:3},{value:"7. Advanced CronJob Time zones",id:"7-advanced-cronjob-time-zones",level:3},{value:"8. Other changes",id:"8-other-changes",level:3},{value:"Get Involved",id:"get-involved",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"We\u2019re pleased to announce the release of OpenKruise 1.3, which is a CNCF Sandbox level project."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://openkruise.io",children:"OpenKruise"})," is an extended component suite for Kubernetes, which mainly focuses on application automations, such as deployment, upgrade, ops and availability protection. Mostly features provided by OpenKruise are built primarily based on CRD extensions. They can work in pure Kubernetes clusters without any other dependences."]}),"\n",(0,t.jsx)(n.h2,{id:"whats-new",children:"What's new?"}),"\n",(0,t.jsxs)(n.p,{children:["In release v1.3, OpenKruise provides a new CRD named ",(0,t.jsx)(n.code,{children:"PodProbeMarker"}),", improves its performance in large-scale clusters, Advanced DaemonSet support pre-download image,\nand some new features have been added to CloneSet, WorkloadSpread, AdvancedCronJob, SidecarSet etc."]}),"\n",(0,t.jsx)(n.p,{children:"Here we are going to introduce some changes of it."}),"\n",(0,t.jsx)(n.h3,{id:"1-new-crd-and-controller-podprobemarker",children:"1. New CRD and Controller: PodProbeMarker"}),"\n",(0,t.jsx)(n.p,{children:"Kubernetes provides three Pod lifecycle management:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Readiness Probe"})," Used to determine whether the business container is ready to respond to user requests. If the probe fails, the Pod will be removed from Service Endpoints."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Liveness Probe"})," Used to determine the health status of the container. If the probe fails, the kubelet will restart the container."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Startup Probe"})," Used to know when a container application has started. If such a probe is configured, it disables liveness and readiness checks until it succeeds."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["So the Probe capabilities provided in Kubernetes have defined specific semantics and related behaviors.\n",(0,t.jsx)(n.strong,{children:"In addition, there is actually a need to customize Probe semantics and related behaviors"}),", such as:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"GameServer defines Idle Probe to determine whether the Pod currently has a game match"}),", if not, from the perspective of cost optimization, the Pod can be scaled down."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"K8S Operator defines the main-secondary probe to determine the role of the current Pod (main or secondary)"}),". When upgrading, the secondary can be upgraded first,\nso as to achieve the behavior of selecting the main only once during the upgrade process, reducing the service interruption time during the upgrade process."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"OpenKruise provides the ability to customize the Probe and return the result to the Pod Status, and the user can decide the follow-up behavior based on the probe result."}),"\n",(0,t.jsx)(n.p,{children:"An object of PodProbeMarker may look like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: PodProbeMarker\nmetadata:\n  name: game-server-probe\n  namespace: ns\nspec:\n  selector:\n    matchLabels:\n      app: game-server\n  probes:\n  - name: Idle\n    containerName: game-server\n    probe:\n      exec: \n        command:\n        - /home/game/idle.sh\n      initialDelaySeconds: 10\n      timeoutSeconds: 3\n      periodSeconds: 10\n      successThreshold: 1\n      failureThreshold: 3\n    markerPolicy:\n    - state: Succeeded\n      labels:\n        gameserver-idle: 'true'\n      annotations:\n        controller.kubernetes.io/pod-deletion-cost: '-10'\n    - state: Failed\n      labels:\n        gameserver-idle: 'false'\n      annotations:\n        controller.kubernetes.io/pod-deletion-cost: '10'\n    podConditionType: game.io/idle\n"})}),"\n",(0,t.jsx)(n.p,{children:"PodProbeMarker results can be viewed at Pod Object:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    app: game-server\n    gameserver-idle: 'true'\n  annotations:\n    controller.kubernetes.io/pod-deletion-cost: '-10'\n  name: game-server-58cb9f5688-7sbd8\n  namespace: ns\nspec:\n  ...\nstatus:\n  conditions:\n    # podConditionType\n  - type: game.io/idle\n    # Probe State 'Succeeded' indicates 'True', and 'Failed' indicates 'False'\n    status: \"True\"\n    lastProbeTime: \"2022-09-09T07:13:04Z\"\n    lastTransitionTime: \"2022-09-09T07:13:04Z\"\n    # If the probe fails to execute, the message is stderr\n    message: \"\"\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-performance-optimization-significant-performance-improvements-for-large-scale-clusters",children:"2. Performance optimization: significant performance improvements for large-scale clusters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/openkruise/kruise/pull/1026",children:"#1026"})," The introduction of a delayed queueing mechanism significantly optimizes the CloneSet controller work queue buildup problem when kruise-manager is pulled up in large-scale application clusters,\nideally reducing initialization time by more than 80%."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/openkruise/kruise/pull/1027",children:"#1027"})," Optimize PodUnavailableBudget controller Event Handler logic to reduce the number of irrelevant Pods in the queue."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/openkruise/kruise/pull/1011",children:"#1011"})," The caching mechanism optimizes the CPU and Memory consumption of Advanced DaemonSet's repetitive simulation of Pod scheduling computations in large-scale clusters."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/openkruise/kruise/pull/1015",children:"#1015"}),", ",(0,t.jsx)(n.a,{href:"https://github.com/openkruise/kruise/pull/1068",children:"#1068"})," Significantly reduce runtime memory consumption in large clusters. Complete the Disable DeepCopy feature started in v1.1, and reduce the conversion consumption of expressions type label selector."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-sidecarset-support-inject-specific-historical-version",children:"3. SidecarSet support inject specific historical version"}),"\n",(0,t.jsxs)(n.p,{children:["SidecarSet will record historical revision of some fields such as ",(0,t.jsx)(n.code,{children:"containers"}),", ",(0,t.jsx)(n.code,{children:"volumes"}),", ",(0,t.jsx)(n.code,{children:"initContainers"}),", ",(0,t.jsx)(n.code,{children:"imagePullSecrets"})," and ",(0,t.jsx)(n.code,{children:"patchPodMetadata"})," via ControllerRevision.\n",(0,t.jsx)(n.strong,{children:"Based on this feature, you can easily select a specific historical revision to inject when creating Pods, rather than always inject the latest revision of sidecar."})]}),"\n",(0,t.jsxs)(n.p,{children:["SidecarSet records ControllerRevision in the same namespace as Kruise Manager. You can execute ",(0,t.jsx)(n.code,{children:"kubectl get controllerrevisions -n kruise-system -l kruise.io/sidecarset-name=<your-sidecarset-name>"})," to list the ControllerRevisions of your SidecarSet.\nMoreover, the ControllerRevision name of current SidecarSet revision is shown in ",(0,t.jsx)(n.code,{children:"status.latestRevision"})," field, so you can record it very easily."]}),"\n",(0,t.jsx)(n.p,{children:"There are two configuration methods as follows:"}),"\n",(0,t.jsx)(n.h4,{id:"select-revision-via-controllerrevision-name",children:"select revision via ControllerRevision name"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\nspec:\n  ...\n  updateStrategy:\n    partition: 90%\n  injectionStrategy:\n    revision:\n      revisionName: <specific-controllerrevision-name>\n"})}),"\n",(0,t.jsx)(n.h4,{id:"select-revision-via-custom-version-label",children:"select revision via custom version label"}),"\n",(0,t.jsxs)(n.p,{children:["You can add or update the label ",(0,t.jsx)(n.code,{children:"apps.kruise.io/sidecarset-custom-version=<your-version-id>"})," to SidecarSet when creating or publishing SidecarSet, to mark each historical revision.\nSidecarSet will bring this label down to the corresponding ControllerRevision object, and you can easily use the ",(0,t.jsx)(n.code,{children:"<your-version-id>"})," to describe which historical revision you want to inject."]}),"\n",(0,t.jsxs)(n.p,{children:["Assume that you are publishing ",(0,t.jsx)(n.code,{children:"version-2"})," in canary way (you wish only 10% Pods will be upgraded), and you want to inject the stable ",(0,t.jsx)(n.code,{children:"version-1"})," to newly-created Pods to reduce the risk of the canary publishing:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nmetadata:\n  name: sidecarset\n  labels:\n    apps.kruise.io/sidecarset-custom-version: example/version-2\nspec:\n  ...\n  updateStrategy:\n    partition: 90%\n  injectionStrategy:\n    revision:\n      customVersion: example/version-1\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-sidecarset-support-inject-pod-annotations",children:"4. SidecarSet support inject pod annotations"}),"\n",(0,t.jsx)(n.p,{children:"SidecarSet support inject pod annotations, as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: SidecarSet\nspec:\n  containers:\n    ...\n  patchPodMetadata:\n  - annotations:\n      oom-score: \'{"log-agent": 1}\'\n      custom.example.com/sidecar-configuration: \'{"command": "/home/admin/bin/start.sh", "log-level": "3"}\'\n    patchPolicy: MergePatchJson\n  - annotations:\n      apps.kruise.io/container-launch-priority: Ordered\n    patchPolicy: Overwrite | Retain\n'})}),"\n",(0,t.jsx)(n.p,{children:"patchPolicy is the injected policy, as follows:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Retain:"})," By default, if annotation[key]=value exists in the Pod, the original value of the Pod will be retained. Inject annotations[key]=value2 only if annotation[key] does not exist in the Pod."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Overwrite:"})," Corresponding to Retain, when annotation[key]=value exists in the Pod, it will be overwritten value2."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"MergePatchJson:"}),' Corresponding to Overwrite, the annotations value is a json string. If the annotations[key] does not exist in the Pod, it will be injected directly. If it exists, do a json value merge.\nFor example: annotations[oom-score]=\'{"main": 2}\' exists in the Pod, after injection, the value json is merged into annotations[oom-score]=\'{"log-agent": 1, "main": 2}\'.']}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," When the patchPolicy is Overwrite and MergePatchJson, the annotations can be updated synchronously when the SidecarSet in-place update the Sidecar Container.\nHowever, if only the annotations are modified, it will not take effect. It must be in-place update together with the sidecar container image.\nWhen patchPolicy is Retain, the annotations will not be updated when the SidecarSet in-place update the Sidecar Container."]}),"\n",(0,t.jsx)(n.p,{children:"According to the above configuration, when the sidecarSet is injected into the sidecar container, it will inject Pod annotations synchronously, as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: Pod\nmetadata:\n  annotations:\n    apps.kruise.io/container-launch-priority: Ordered\n    oom-score: \'{"log-agent": 1, "main": 2}\'\n    custom.example.com/sidecar-configuration: \'{"command": "/home/admin/bin/start.sh", "log-level": "3"}\'\nname: test-pod\nspec:\n  containers:\n    ...\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," SidecarSet should not modify any configuration outside the sidecar container for security consideration, so if you want to use this capability, you need to first configure SidecarSet_PatchPodMetadata_WhiteList whitelist\nor turn off whitelist checks via Feature-gate SidecarSetPatchPodMetadataDefaultsAllowed=true."]}),"\n",(0,t.jsx)(n.h3,{id:"5-advanced-daemonset-support-pre-downloading-image-for-update",children:"5. Advanced DaemonSet support pre-downloading image for update"}),"\n",(0,t.jsxs)(n.p,{children:["If you have enabled the ",(0,t.jsx)(n.code,{children:"PreDownloadImageForDaemonSetUpdate"})," feature-gate,\nDaemonSet controller will automatically pre-download the image you want to update to the nodes of all old Pods.\nIt is quite useful to accelerate the progress of applications upgrade."]}),"\n",(0,t.jsxs)(n.p,{children:["The parallelism of each new image pre-downloading by DaemonSet is ",(0,t.jsx)(n.code,{children:"1"}),", which means the image is downloaded on nodes one by one.\nYou can change the parallelism using ",(0,t.jsx)(n.code,{children:"apps.kruise.io/image-predownload-parallelism"})," annotation on DaemonSet according to the capability of image registry,\nfor registries with more bandwidth and P2P image downloading ability, a larger parallelism can speed up the pre-download process."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: apps.kruise.io/v1alpha1\nkind: DaemonSet\nmetadata:\n  annotations:\n    apps.kruise.io/image-predownload-parallelism: "10"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"6-cloneset-scaling-with-preparingdelete",children:"6. CloneSet Scaling with PreparingDelete"}),"\n",(0,t.jsxs)(n.p,{children:["CloneSet considers Pods in ",(0,t.jsx)(n.code,{children:"PreparingDelete"})," state as normal by default, which means these Pods will still be calculated in the ",(0,t.jsx)(n.code,{children:"replicas"})," number."]}),"\n",(0,t.jsx)(n.p,{children:"In this situation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["if you scale down ",(0,t.jsx)(n.code,{children:"replicas"})," from ",(0,t.jsx)(n.code,{children:"N"})," to ",(0,t.jsx)(n.code,{children:"N-1"}),", when the Pod to be deleted is still in ",(0,t.jsx)(n.code,{children:"PreparingDelete"}),", you scale up ",(0,t.jsx)(n.code,{children:"replicas"})," to ",(0,t.jsx)(n.code,{children:"N"}),", the CloneSet will move the Pod back to ",(0,t.jsx)(n.code,{children:"Normal"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["if you scale down ",(0,t.jsx)(n.code,{children:"replicas"})," from ",(0,t.jsx)(n.code,{children:"N"})," to ",(0,t.jsx)(n.code,{children:"N-1"})," and put a Pod into ",(0,t.jsx)(n.code,{children:"podsToDelete"}),", when the specific Pod is still in ",(0,t.jsx)(n.code,{children:"PreparingDelete"}),", you scale up ",(0,t.jsx)(n.code,{children:"replicas"})," to ",(0,t.jsx)(n.code,{children:"N"}),", the CloneSet will not create a new Pod until the specific Pod goes into terminating."]}),"\n",(0,t.jsxs)(n.li,{children:["if you specifically delete a Pod without ",(0,t.jsx)(n.code,{children:"replicas"})," changed, when the specific Pod is still in ",(0,t.jsx)(n.code,{children:"PreparingDelete"}),", the CloneSet will not create a new Pod until the specific Pod goes into terminating."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Since Kruise v1.3.0, you can put a ",(0,t.jsx)(n.code,{children:'apps.kruise.io/cloneset-scaling-exclude-preparing-delete: "true"'})," label into CloneSet, which indicates Pods in ",(0,t.jsx)(n.code,{children:"PreparingDelete"})," will not be calculated in the ",(0,t.jsx)(n.code,{children:"replicas"})," number."]}),"\n",(0,t.jsx)(n.p,{children:"In this situation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["if you scale down ",(0,t.jsx)(n.code,{children:"replicas"})," from ",(0,t.jsx)(n.code,{children:"N"})," to ",(0,t.jsx)(n.code,{children:"N-1"}),", when the Pod to be deleted is still in ",(0,t.jsx)(n.code,{children:"PreparingDelete"}),", you scale up ",(0,t.jsx)(n.code,{children:"replicas"})," to ",(0,t.jsx)(n.code,{children:"N"}),", the CloneSet will move the Pod back to ",(0,t.jsx)(n.code,{children:"Normal"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["if you scale down ",(0,t.jsx)(n.code,{children:"replicas"})," from ",(0,t.jsx)(n.code,{children:"N"})," to ",(0,t.jsx)(n.code,{children:"N-1"})," and put a Pod into ",(0,t.jsx)(n.code,{children:"podsToDelete"}),", even if the specific Pod is still in ",(0,t.jsx)(n.code,{children:"PreparingDelete"}),", you scale up ",(0,t.jsx)(n.code,{children:"replicas"})," to ",(0,t.jsx)(n.code,{children:"N"}),", the CloneSet will create a new Pod immediately."]}),"\n",(0,t.jsxs)(n.li,{children:["if you specifically delete a Pod without ",(0,t.jsx)(n.code,{children:"replicas"})," changed, even if the specific Pod is still in ",(0,t.jsx)(n.code,{children:"PreparingDelete"}),", the CloneSet will create a new Pod immediately."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"7-advanced-cronjob-time-zones",children:"7. Advanced CronJob Time zones"}),"\n",(0,t.jsx)(n.p,{children:"All CronJob schedule: times are based on the timezone of the kruise-controller-manager by default,\nwhich means the timezone set for the kruise-controller-manager container determines the timezone that the cron job controller uses."}),"\n",(0,t.jsxs)(n.p,{children:["However, we have introduce a ",(0,t.jsx)(n.code,{children:"spec.timeZone"})," field in v1.3.0.\nYou can set it to the name of a valid time zone name. For example, setting ",(0,t.jsx)(n.code,{children:'spec.timeZone: "Etc/UTC"'})," instructs Kruise to interpret the schedule relative to Coordinated Universal Time."]}),"\n",(0,t.jsx)(n.p,{children:"A time zone database from the Go standard library is included in the binaries and used as a fallback in case an external database is not available on the system."}),"\n",(0,t.jsx)(n.h3,{id:"8-other-changes",children:"8. Other changes"}),"\n",(0,t.jsxs)(n.p,{children:["For more changes, their authors and commits, you can read the ",(0,t.jsx)(n.a,{href:"https://github.com/openkruise/kruise/releases",children:"Github release"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"get-involved",children:"Get Involved"}),"\n",(0,t.jsxs)(n.p,{children:["Welcome to get involved with OpenKruise by joining us in Github/Slack/DingTalk/WeChat.\nHave something you\u2019d like to broadcast to our community?\nShare your voice at our ",(0,t.jsx)(n.a,{href:"https://shimo.im/docs/gXqmeQOYBehZ4vqo",children:"Bi-weekly community meeting (Chinese)"}),", or through the channels below:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Join the community on ",(0,t.jsx)(n.a,{href:"https://kubernetes.slack.com/channels/openkruise",children:"Slack"})," (English)."]}),"\n",(0,t.jsxs)(n.li,{children:["Join the community on DingTalk: Search GroupID ",(0,t.jsx)(n.code,{children:"23330762"})," (Chinese)."]}),"\n",(0,t.jsxs)(n.li,{children:["Join the community on WeChat (new): Search User ",(0,t.jsx)(n.code,{children:"openkruise"})," and let the robot invite you (Chinese)."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);