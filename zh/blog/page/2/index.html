<!doctype html>
<html lang="zh" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">Blog | OpenKruise</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://openkruise.io/zh/blog/page/2"><meta data-rh="true" property="og:locale" content="zh"><meta data-rh="true" property="og:locale:alternate" content="en"><meta data-rh="true" name="docusaurus_locale" content="zh"><meta data-rh="true" name="docsearch:language" content="zh"><meta data-rh="true" property="og:title" content="Blog | OpenKruise"><meta data-rh="true" name="description" content="Blog"><meta data-rh="true" property="og:description" content="Blog"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/zh/img/openkruise.ico"><link data-rh="true" rel="canonical" href="https://openkruise.io/zh/blog/page/2"><link data-rh="true" rel="alternate" href="https://openkruise.io/blog/page/2" hreflang="en"><link data-rh="true" rel="alternate" href="https://openkruise.io/zh/blog/page/2" hreflang="zh"><link data-rh="true" rel="alternate" href="https://openkruise.io/blog/page/2" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://default id-dsn.algolia.net" crossorigin="anonymous"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"Blog","@id":"https://openkruise.io/zh/blog/page/2","mainEntityOfPage":"https://openkruise.io/zh/blog/page/2","headline":"Blog","description":"Blog","blogPost":[{"@type":"BlogPosting","@id":"https://openkruise.io/zh/blog/sidecarset","mainEntityOfPage":"https://openkruise.io/zh/blog/sidecarset","url":"https://openkruise.io/zh/blog/sidecarset","headline":"OpenKruise 0.8.0, A Powerful Tool for Sidecar Container Management","name":"OpenKruise 0.8.0, A Powerful Tool for Sidecar Container Management","description":"OpenKruise 是阿里云开源的云原生应用自动化管理套件，也是当前托管在 Cloud Native Computing Foundation (CNCF) 下的Sandbox项目。它来自阿里巴巴多年来容器化、云原生的技术沉淀，是阿里内部生产环境大规模应用的基于Kubernetes之上的标准扩展组件，也是紧贴上游社区标准、适应互联网规模化场景的技术理念与最佳实践。","datePublished":"2021-03-15T00:00:00.000Z","author":{"@type":"Person","name":"Mingshan Zhao","description":"Member of OpenKruise","url":"https://github.com/zmberg","image":"https://github.com/zmberg.png"},"keywords":[]},{"@type":"BlogPosting","@id":"https://openkruise.io/zh/blog/uniteddeployment","mainEntityOfPage":"https://openkruise.io/zh/blog/uniteddeployment","url":"https://openkruise.io/zh/blog/uniteddeployment","headline":"UnitedDeploymemt - Supporting Multi-domain Workload Management","name":"UnitedDeploymemt - Supporting Multi-domain Workload Management","description":"Ironically, probably every cloud user knew (or should realized that) failures in Cloud resources","datePublished":"2019-11-20T00:00:00.000Z","author":{"@type":"Person","name":"Fei Guo","description":"Maintainer of OpenKruise","url":"https://github.com/Fei-Guo","image":"https://github.com/Fei-Guo.png"},"keywords":[]},{"@type":"BlogPosting","@id":"https://openkruise.io/zh/blog/learning-concurrent-reconciling","mainEntityOfPage":"https://openkruise.io/zh/blog/learning-concurrent-reconciling","url":"https://openkruise.io/zh/blog/learning-concurrent-reconciling","headline":"Learning Concurrent Reconciling","name":"Learning Concurrent Reconciling","description":"The concept of controller in Kubernete is one of the most important reasons that make it successful.","datePublished":"2019-11-10T00:00:00.000Z","author":{"@type":"Person","name":"Fei Guo","description":"Maintainer of OpenKruise","url":"https://github.com/Fei-Guo","image":"https://github.com/Fei-Guo.png"},"keywords":[]},{"@type":"BlogPosting","@id":"https://openkruise.io/zh/blog/workload-classification-guidance","mainEntityOfPage":"https://openkruise.io/zh/blog/workload-classification-guidance","url":"https://openkruise.io/zh/blog/workload-classification-guidance","headline":"Kruise Workload Classification Guidance","name":"Kruise Workload Classification Guidance","description":"Kubernetes 目前并没有为一个应用应该使用哪个控制器提供明确的指引，这尤其不利于用户理解应用和 workload 的关系。","datePublished":"2019-10-10T00:00:00.000Z","author":[{"@type":"Person","name":"Fei Guo","description":"Maintainer of OpenKruise","url":"https://github.com/Fei-Guo","image":"https://github.com/Fei-Guo.png"},{"@type":"Person","name":"Siyu Wang","description":"Maintainer of OpenKruise","url":"https://github.com/FillZpp","image":"https://github.com/FillZpp.png"}],"keywords":[]}]}</script><link rel="alternate" type="application/rss+xml" href="/zh/blog/rss.xml" title="OpenKruise RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh/blog/atom.xml" title="OpenKruise Atom Feed">




<link rel="search" type="application/opensearchdescription+xml" title="OpenKruise" href="/zh/opensearch.xml"><link rel="stylesheet" href="/zh/assets/css/styles.3c6f9254.css">
<script src="/zh/assets/js/runtime~main.798d9982.js" defer="defer"></script>
<script src="/zh/assets/js/main.eecd3959.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const a=new URLSearchParams(window.location.search).entries();for(var[t,e]of a)if(t.startsWith("docusaurus-data-")){var n=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(n,e)}}catch(t){}}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus"><link rel="preload" as="image" href="/zh/img/openkruise.ico"><link rel="preload" as="image" href="https://github.com/zmberg.png"><link rel="preload" as="image" href="https://github.com/Fei-Guo.png"><link rel="preload" as="image" href="https://github.com/FillZpp.png"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><div class="announcementBar_mb4j" role="banner"><div class="announcementBarPlaceholder_vyr4"></div><div class="content_knG7 announcementBarContent_xLdY">⭐️ If you like OpenKruise, give it a star on <a target="_blank" rel="noopener noreferrer" href="https://github.com/openkruise/kruise">GitHub</a>! ⭐️</div><button type="button" aria-label="Close" class="clean-btn close closeButton_CVFx announcementBarClose_gvF7"><svg viewBox="0 0 15 15" width="14" height="14"><g stroke="currentColor" stroke-width="3.1"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/zh/"><div class="navbar__logo"><img src="/zh/img/openkruise.ico" alt="OpenKruise" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/zh/img/openkruise.ico" alt="OpenKruise" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">OpenKruise</b></a><a class="navbar__item navbar__link" href="/zh/docs/">Kruise</a><a class="navbar__item navbar__link" href="/zh/rollouts/introduction">Rollouts</a><a class="navbar__item navbar__link" href="/zh/kruisegame/introduction">Kruise-Game</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/zh/blog">博客</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" aria-haspopup="true" aria-expanded="false" role="button" href="/zh/docs/">v1.8</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/zh/docs/next/">v1.9</a></li><li><a class="dropdown__link" href="/zh/docs/">v1.8</a></li><li><a class="dropdown__link" href="/zh/docs/v1.7/">v1.7</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>简体中文</a><ul class="dropdown__menu"><li><a href="/blog/page/2" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">English</a></li><li><a href="/zh/blog/page/2" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh">简体中文</a></li></ul></div><a href="https://github.com/openkruise/kruise" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">All posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2025</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/elastic">面向Workload级别的灵活可配置Serverless弹性解决方案</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2023</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/openkruise-1.4">OpenKruise V1.4 版本解读：新增Job Sidecar Terminator能力</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2022</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/openkruise-1.3">OpenKruise v1.3：新增自定义 Pod Probe 探针能力与大规模集群性能显著提升</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/openkruise-1.2">OpenKruise v1.2：新增 PersistentPodState 实现有状态 Pod 拓扑固定与 IP 复用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/openkruise-1.1">OpenKruise v1.1：功能增强与上游对齐，大规模场景性能优化</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2021</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/openkruise-1.0">OpenKruise v1.0：云原生应用自动化达到新的高峰</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/workloadspread">OpenKruise v0.10.0 新特性WorkloadSpread解读</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/openkruise-0.10.0">OpenKruise 0.10.0：新增应用弹性拓扑管理、应用防护等能力</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/sidecarset-hotupdate">OpenKruise 0.9.0, SidecarSet Helps Mesh Container Hot Upgrade</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/openkruise-0.9.0">OpenKruise 0.9.0：新增Pod容器重启、资源删除防护等功能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/sidecarset">OpenKruise 0.8.0, A Powerful Tool for Sidecar Container Management</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2019</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/uniteddeployment">UnitedDeploymemt - Supporting Multi-domain Workload Management</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/learning-concurrent-reconciling">Learning Concurrent Reconciling</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh/blog/workload-classification-guidance">Kruise Workload Classification Guidance</a></li></ul></div></nav></aside><main class="col col--7"><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/zh/blog/sidecarset">OpenKruise 0.8.0, A Powerful Tool for Sidecar Container Management</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2021-03-15T00:00:00.000Z">2021年3月15日</time> · <!-- -->阅读需要 1 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/zmberg" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://github.com/zmberg.png" alt="Mingshan Zhao"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://github.com/zmberg" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp">Mingshan Zhao</span></a></div><small class="authorTitle_nd0D" title="Member of OpenKruise">Member of OpenKruise</small><div class="authorSocials_rSDt"></div></div></div></div></div></header><div class="markdown"><p>OpenKruise 是阿里云开源的云原生应用自动化管理套件，也是当前托管在 Cloud Native Computing Foundation (CNCF) 下的Sandbox项目。它来自阿里巴巴多年来容器化、云原生的技术沉淀，是阿里内部生产环境大规模应用的基于Kubernetes之上的标准扩展组件，也是紧贴上游社区标准、适应互联网规模化场景的技术理念与最佳实践。</p>
<p>OpenKruise在2021.3.4发布了最新的v0.8.0版本，其中增强了SidecarSet的能力，特别是对日志管理类Sidecar有了更加完善的支持。</p>
<h1>背景</h1>
<p>Sidecar是云原生中一种非常重要的容器设计模式，它将辅助能力从主容器中剥离出来成为单独的sidecar容器。在微服务架构中，通常也使用sidecar模式将微服务中的配置管理、服务发现、路由、熔断等通用能力从主程序中剥离出来，从而极大降低了微服务架构中的复杂性。随着Service Mesh的逐步风靡，sidecar模式也日益深入人心，在阿里巴巴集团内部也大量使用sidecar模式来管理诸如运维、安全、消息中间件等通用组件。</p>
<p>在Kubernetes集群中，Pod不仅可以实现主容器与sidecar容器的构建，同时提供了许多功能强大的workload（例如：deployment、statefulset）来对Pod进行管理、升级。但是随着kubernetes集群上的业务日益增多，sidecar容器的种类与规模也随之日益庞大，对线上sidecar容器的管理和升级成为了愈发繁杂的工作：</p>
<ol>
<li>业务Pod里面包含了运维、安全、代理等多个sidecar容器，业务线同学不仅要完成自身主容器的配置，而且还需要熟悉这些sidecar容器的配置，这不仅增加了业务同学的工作量，同时也无形增加了sidecar容器配置的风险。</li>
<li>sidecar容器的升级需要连同业务主容器一起重启（deployment、statefulset等workload基于Pod销毁、重建的模式，来实现Pod的滚动升级），推动和升级支撑着线上数百款业务的sidecar容器，必然存在着极大的业务阻力。</li>
<li>作为sidecar容器的提供者对线上诸多各种配置以及版本的sidecar容器没有直接有效的升级手段，这对sidecar容器的管理意味着极大的潜在风险。</li>
</ol>
<p>阿里巴巴集团内部拥有着百万级的容器数量连同上面承载的上千个业务，因此，sidecar容器的管理与升级也就成为了亟待完善的主题。因此，我们总结了内部许多sidecar容器的通用化需求，并将其沉淀到OpenKruise上面，最终抽象为SidecarSet作为管理和升级种类繁多sidecar容器的利器。</p>
<h1>OpenKruise SidecarSet</h1>
<p>SidecarSet是OpenKruise中针对sidecar抽象出来的概念，负责注入和升级kubernetes集群中的sidecar容器，是OpenKruise的核心workload之一。它提供了非常丰富的功能，用户使用SidecarSet可以非常方便实现sidecar容器的管理。主要特性如下：</p>
<ol>
<li>配置单独管理：为每一个sidecar容器配置单独的SidecarSet配置，方便管理</li>
<li>自动注入：在新建、扩容、重建pod的场景中，实现sidecar容器的自动注入</li>
<li>原地升级：支持不重建pod的方式完成sidecar容器的原地升级，不影响业务主容器，并包含丰富的灰度发布策略</li>
</ol>
<p>注意：针对Pod中包含多个容器的模式，其中对外提供主要业务逻辑能力的容器称之为 主容器，其它一些如日志采集、安全、代理等辅助能力的容器称之为 Sidecar容器。例如：一个对外提供web能力的pod，nginx容器提供主要的web server能力即为 主容器，logtail容器负责采集、上报nginx日志即为 Sidecar容器。本文中的SidecarSet资源抽象也是为解决 Sidecar容器 的一些问题。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="sidecar-logging-architectures">Sidecar logging architectures<a href="#sidecar-logging-architectures" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading">​</a></h2>
<p>应用日志可以让你了解应用内部的运行状况，日志对调试问题和监控集群活动非常有用。应用容器化后，最简单且最广泛采用的日志记录方式就是写入标准输出和标准错误。</p>
<p>但是，在当前分布式系统、大规模集群的时代下，上述方案还不足以达到生产环境的标准。首先，对于分布式系统而言，日志都是分散在单个容器里面，没有一个统一汇总的地方。其次，如果发生容器崩溃、Pod被驱逐等场景，会出现日志丢失的情况。因此，需要一种更加可靠，独立于容器生命周期的日志解决方案。</p>
<p>Sidecar logging architectures 是将logging agent放到一个独立的sidecar容器中，通过共享日志目录的方式，实现容器日志的采集，然后存储到日志平台的后端存储。</p>
<p><img decoding="async" loading="lazy" alt="logsidecar" src="/zh/assets/images/logsidecar-e3784d7378b906f91df3393e6d716490.png" width="500" height="250" class="img_ev3q"></p>
<p>阿里巴巴以及蚂蚁集团内部同样也是基于这种架构实现了容器的日志采集，下面我将介绍OpenKruise SidecarSet如何助力 Sidecar日志架构在kubernetes集群中的大规模落地实践。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="自动注入">自动注入<a href="#自动注入" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading">​</a></h2>
<p>OpenKruise SidecarSet基于kubernetes AdmissionWebhook机制实现了sidecar容器的自动注入，因此只要将sidecar配置到SidecarSet中，不管用户用 CloneSet、Deployment、StatefulSet 等任何方式部署，扩出来的 Pod 中都会注入定义好的 sidecar 容器。</p>
<p><img decoding="async" loading="lazy" alt="inject sidecar" src="/zh/assets/images/inject_sidecar-d17db953d6c3b59583124c7c272549b0.png" width="726" height="448" class="img_ev3q"></p>
<p>Sidecar容器的所有者只需要配置自身的SidecarSet，就可以在业务无感知的情况下完成sidecar容器的注入，这种方式极大的降低了sidecar容器使用的门槛，也方便了sidecar所有者的管理工作。为了满足sidecar注入的多种场景，SidecarSet除containers之外还扩展了如下字段：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># sidecarset.yaml</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">apiVersion: apps.kruise.io/v1alpha1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kind: SidecarSet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">metadata:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  name: test-sidecarset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spec:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  # 通过selector选择pod</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  selector:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    matchLabels:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      app: web-server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  # 指定 namespace 生效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  namespace: ns-1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  # container definition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  containers:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  - name: logtail</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    image: logtail:1.0.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # 共享指定卷</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volumeMounts:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - name: web-log</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      mountPath: /var/log/web</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # 共享所有卷</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shareVolumePolicy:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      type: disabled</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # 环境变量共享</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transferEnv:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - sourceContainerName: web-server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # TZ代表时区，例如：web-server容器中存在环境变量 TZ=Asia/Shanghai</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      envName: TZ</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  volumes:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - name: web-log</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      emptyDir: {}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>Pod选择器<!-- -->
<ul>
<li>支持selector来选择要注入的Pod，如示例中将选择labels[app] = web-server的pod，将logtail容器注入进去，也可以在所有的pod中添加一个labels[inject/logtail] = true的方式，来实现全局性的sidecar注入。</li>
<li>namespace：sidecarSet默认是全局生效的，如果只想对某一个namespace生效，则配置该参数</li>
</ul>
</li>
<li>数据卷共享：<!-- -->
<ul>
<li>共享指定卷：通过volumeMounts和volumes可以完成与主容器的特定卷的共享，如示例中通过共享web-log volume来达到日志采集的效果</li>
<li>共享所有卷：通过 shareVolumePolicy = enabled | disabled 来控制是否挂载pod主容器的所有卷卷，常用于日志收集等 sidecar，配置为 enabled 后会把应用容器中所有挂载点注入 sidecar 同一路经下(sidecar中本身就有声明的数据卷和挂载点除外）</li>
</ul>
</li>
<li>环境变量共享 可以通过 transferEnv 从其它容器中获取环境变量，会把名为 sourceContainerName 容器中名为 envName 的环境变量拷贝到本sidecar容器，如示例中 日志sidecar容器共享了主容器的时区TZ，这在海外环境中尤其常见</li>
</ul>
<p>注意：kubernetes社区对于已经创建的Pod不允许修改container数量，所以上述注入能力只能发生在Pod创建阶段，对于已经创建的Pod需要通过重建的方式来注入。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="原地升级">原地升级<a href="#原地升级" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading">​</a></h2>
<p>SidecarSet不仅实现sidecar容器的注入，而且复用了OpenKruise中原地升级的特性，实现了在不重启Pod和主容器的前提下单独升级sidecar容器的能力。由于这种升级方式基本上能做到业务方无感知的程度，所以sidecar容器的升级已不再是上下交困的难题，从而极大解放了sidecar的所有者，提升了sidecar版本迭代的速度。</p>
<p><img decoding="async" loading="lazy" alt="inplace sidecar" src="/zh/assets/images/inplace_sidecar-f00ef87888dab2a820b7401f01ced12c.png" width="597" height="448" class="img_ev3q"></p>
<p>注意：kubernetes社区对于已经创建的Pod只允许修改 container.image 字段，因此对于sidecar容器的修改包含除 container.image 的其它字段，则需要通过Pod重建的方式，不能直接原地升级。</p>
<p>为了满足一些复杂的sidecar升级场景，SidecarSet除了原地升级以外，还提供了非常丰富的灰度发布策略。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="灰度发布">灰度发布<a href="#灰度发布" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading">​</a></h2>
<p>灰度发布应该算是日常发布中最常见的一种手段，它能够比较平滑的完成sidecar容器的发布，尤其是在大规模集群的场景下，强烈建议使用这种方式。下面是 首批暂停，后续基于 最大不可用 滚动发布 的例子，假设一个有1000个pod需要发布：</p>
<div class="language-yaml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-yaml codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">apiVersion</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> apps.kruise.io/v1alpha1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">kind</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> SidecarSet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">metadata</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> sidecarset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">spec</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic"># ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">updateStrategy</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">type</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> RollingUpdate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">partition</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">980</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">maxUnavailable</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 10%</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>上述配置首先发布（1000 - 980）= 20 个pod之后就会暂停发布，业务可以观察一段时间发现 sidecar 容器正常后，调整重新 update SidecarSet 配置：</p>
<div class="language-yaml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-yaml codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">apiVersion</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> apps.kruise.io/v1alpha1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">kind</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> SidecarSet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">metadata</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> sidecarset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">spec</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic"># ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">updateStrategy</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">type</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> RollingUpdate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">maxUnavailable</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 10%</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这样调整后，对于余下的 980 个pod，将会按照最大不可用的数量（10% * 1000 = 100）的顺序进行发布，直到所有的pod都发布完成。</p>
<p>Partition 的语义是 保留旧版本 Pod 的数量或百分比，默认为 0。这里的 partition 不表示任何 order 序号。如果在发布过程中设置了 partition:</p>
<ul>
<li>如果是数字，控制器会将 (replicas - partition) 数量的 Pod 更新到最新版本。</li>
<li>如果是百分比，控制器会将 (replicas * (100% - partition)) 数量的 Pod 更新到最新版本。</li>
</ul>
<p>MaxUnavailable 是发布过程中保证的，同一时间下最大不可用的 Pod 数量，默认值为 1。用户可以将其设置为绝对值或百分比（百分比会被控制器按照selected pod做基数来计算出一个背后的绝对值）。</p>
<p>注意：maxUnavailable 和 partition 两个值是没有必然关联。举例：</p>
<ul>
<li>当 {matched pod}=100,partition=50,maxUnavailable=10，控制器会发布 50 个 Pod 到新版本，但是发布窗口为 10，即同一时间只会发布 10 个 Pod，每发布好一个 Pod 才会再找一个发布，直到 50 个发布完成。</li>
<li>当 {matched pod}=100,partition=80,maxUnavailable=30，控制器会发布 20 个 Pod 到新版本，因为满足 maxUnavailable 数量，所以这 20 个 Pod 会同时发布。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="金丝雀发布">金丝雀发布<a href="#金丝雀发布" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading">​</a></h2>
<p>对于有金丝雀发布需求的业务，可以通过strategy.selector来实现。方式：对于需要率先金丝雀灰度的pod打上固定的labels[canary.release] = true，再通过strategy.selector.matchLabels来选中该pod</p>
<div class="language-yaml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-yaml codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">apiVersion</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> apps.kruise.io/v1alpha1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">kind</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> SidecarSet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">metadata</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> sidecarset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">spec</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic"># ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">updateStrategy</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">type</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> RollingUpdate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">selector</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">matchLabels</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">canary.release</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;true&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">maxUnavailable</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 10%</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>上述配置只会发布打上金丝雀labels的容器，在完成金丝雀验证之后，通过将 updateStrategy.selector 配置去掉，就会继续通过 最大不可用 来滚动发布。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="打散发布">打散发布<a href="#打散发布" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading">​</a></h2>
<p>SidecarSet对于pod的升级顺序，默认按照如下规则：</p>
<ul>
<li>对升级的pod集合，保证多次升级的顺序一致</li>
<li>选择优先顺序是（越小优先级越高）： unscheduled &lt; scheduled, pending &lt; unknown &lt; running, not-ready &lt; ready, newer pods &lt; older pods</li>
</ul>
<p>除了上述默认发布顺序之外，scatter打散策略允许用户 自定义将符合某些标签的 Pod 打散 到整个发布过程中。比如，对于像 logtail 这种全局性的 sidecar container，一个集群当中很可能注入了几十个业务pod，因此可以使用基于 应用名 的方式来打散logtail的方式进行发布，实现 不同应用间打散灰度发布 的效果，并且这种方式可以同 最大不可用 一起使用。</p>
<div class="language-yaml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-yaml codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">apiVersion</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> apps.kruise.io/v1alpha1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">kind</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> SidecarSet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">metadata</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> sidecarset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">spec</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">updateStrategy</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">type</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> RollingUpdate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic"># 配置pod labels，假设所有的pod都包含labels[app_name]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">scatterStrategy</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">key</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> app_name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">value</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> nginx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">key</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> app_name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">value</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> web</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">key</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> app_name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">value</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> api</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">gateway</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">maxUnavailable</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 10%</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>注意：当前版本必须要列举所有的应用名称，我们将在下个版本支持 只配置label key 的智能打散方式。</p>
<h1>总结</h1>
<p>本次 OpenKruise v0.8.0 版本的升级，SidecarSet特性主要是完善了 日志管理类Sidecar 场景的能力，后续我们在持续深耕SidecarSet稳定性、性能的同时，也将覆盖更多的场景，比如下一个版本将会增加针对 Service Mesh场景 的支持。同时，我们也欢迎更多的同学参与到 OpenKruise 社区来，共同建设一个场景更加丰富、完善的 K8s 应用管理、交付扩展能力，能够面向更加规模化、复杂化、极致性能的场景。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh/blog/tags/workload">workload</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh/blog/tags/sidecar">sidecar</a></li></ul></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/zh/blog/uniteddeployment">UnitedDeploymemt - Supporting Multi-domain Workload Management</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2019-11-20T00:00:00.000Z">2019年11月20日</time> · <!-- -->阅读需要 1 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/Fei-Guo" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://github.com/Fei-Guo.png" alt="Fei Guo"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://github.com/Fei-Guo" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp">Fei Guo</span></a></div><small class="authorTitle_nd0D" title="Maintainer of OpenKruise">Maintainer of OpenKruise</small><div class="authorSocials_rSDt"></div></div></div></div></div></header><div class="markdown"><p>Ironically, probably every cloud user knew (or should realized that) failures in Cloud resources
are inevitable. Hence, high availability is probably one of the most desirable features that
Cloud Provider offers for cloud users. For example, in AWS, each geographic region has
multiple isolated locations known as Availability Zones (AZs).
AWS provides various AZ-aware solutions to allow the compute or storage resources of the user
applications to be distributed across multiple AZs in order to tolerate AZ failure, which indeed
happened in the past.</p>
<p>In Kubernetes, the concept of AZ is not realized by an API object. Instead,
an AZ is usually represented by a group of hosts that have the same location label.
Although hosts within the same AZ can be identified by labels, the capability of distributing Pods across
AZs was missing in Kubernetes default scheduler. Hence it was difficult to use single
<code>StatefulSet</code> or <code>Deployment</code> to perform  AZ-aware Pods deployment. Fortunately,
in Kubernetes 1.16, a new feature called <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/" target="_blank" rel="noopener noreferrer">&quot;Pod Topology Spread Constraints&quot;</a>
was introduced. Users now can add new constraints in the Pod Spec, and scheduler
will enforce the constraints so that Pods can be distributed across failure
domains such as AZs, regions or nodes, in a uniform fashion.</p>
<p>In Kruise, <strong>UnitedDeploymemt</strong> provides an alternative to achieve high availability in
a cluster that consists of multiple fault domains - that is, managing multiple homogeneous
workloads, and each workload is dedicated to a single <code>Subset</code>. Pod distribution across AZs is
determined by the replica number of each workload.
Since each <code>Subset</code> is associated with a workload, UnitedDeployment can support
finer-grained rollout and deployment strategies.
In addition, UnitedDeploymemt can be further extended to support
multiple clusters! Let us reveal how UnitedDeployment is designed.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="using-subsets-to-describe-domain-topology">Using <code>Subsets</code> to describe domain topology<a href="#using-subsets-to-describe-domain-topology" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading">​</a></h2>
<p>UnitedDeploymemt uses <code>Subset</code> to represent a failure domain. <code>Subset</code> API
primarily specifies the nodes that forms the domain and the number of replicas, or
the percentage of total replicas, run in this domain. UnitedDeployment manages
subset workloads against a specific domain topology, described by a <code>Subset</code> array.</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">type Topology struct {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// Contains the details of each subset.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	Subsets []Subset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type Subset struct {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// Indicates the name of this subset, which will be used to generate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// subset workload name prefix in the format &#x27;&lt;deployment-name&gt;-&lt;subset-name&gt;-&#x27;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	Name string</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// Indicates the node select strategy to form the subset.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	NodeSelector corev1.NodeSelector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// Indicates the number of the subset replicas or percentage of it on the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// UnitedDeployment replicas.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	Replicas *intstr.IntOrString</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>The specification of the subset workload is saved in <code>Spec.Template</code>. UnitedDeployment
only supports <code>StatefulSet</code> subset workload as of now. An interesting part of <code>Subset</code>
design is that now user can specify <strong>customized Pod distribution</strong> across AZs, which is not
necessarily a uniform distribution in some cases. For example, if the AZ
utilization or capacity are not homogeneous, evenly distributing Pods may lead to Pod deployment
failure due to lack of resources. If users have prior knowledge about AZ resource capacity/usage,
UnitedDeployment can help to apply an optimal Pod distribution to ensure overall
cluster utilization remains balanced. Of course, if not specified, a uniform Pod distribution
will be applied to maximize availability.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="customized-subset-rollout-partitions">Customized subset rollout <code>Partitions</code><a href="#customized-subset-rollout-partitions" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading">​</a></h2>
<p>User can update all the UnitedDeployment subset workloads by providing a
new version of subset workload template.
Note that UnitedDeployment does not control
the entire rollout process of all subset workloads, which is typically done by another rollout
controller built on top of it. Since the replica number in each <code>Subset</code> can be different,
it will be much more convenient to allow user to specify the individual rollout <code>Partition</code> of each
subset workload instead of using one <code>Partition</code> to rule all, so that they can be upgraded in the same pace.
UnitedDeployment provides <code>ManualUpdate</code> strategy to customize per subset rollout <code>Partition</code>.</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">type UnitedDeploymentUpdateStrategy struct {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// Type of UnitedDeployment update.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	Type UpdateStrategyType</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// Indicates the partition of each subset.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	ManualUpdate *ManualUpdate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type ManualUpdate struct {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// Indicates number of subset partition.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	Partitions map[string]int32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img decoding="async" loading="lazy" alt="multi-cluster controller" src="/zh/assets/images/uniteddeployment-1-55a005182c47c03e50d0607235d9403e.png" width="670" height="420" class="img_ev3q"></p>
<p>This makes it fairly easy to coordinate multiple subsets rollout. For example,
as illustrated in Figure 1, assuming UnitedDeployment manages three subsets and
their replica numbers are 4, 2, 2 respectively, a rollout
controller can realize a canary release plan of upgrading 50% of Pods in each
subset at a time by setting subset partitions to 2, 1, 1 respectively.
The same cannot be easily achieved by using a single workload controller like <code>StatefulSet</code>
or <code>Deployment</code>.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="multi-cluster-application-management-in-future">Multi-Cluster application management (In future)<a href="#multi-cluster-application-management-in-future" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading">​</a></h2>
<p>UnitedDeployment can be extended to support multi-cluster workload
management. The idea is that <code>Subsets</code> may not only
reside in one cluster, but also spread over multiple clusters.
More specifically, domain topology specification will associate
a <code>ClusterRegistryQuerySpec</code>, which describes the clusters that UnitedDeployment
may distribute Pods to. Each cluster is represented by a custom resource managed by a
ClusterRegistry controller using Kubernetes <a href="https://github.com/kubernetes/cluster-registry" target="_blank" rel="noopener noreferrer">cluster registry APIs</a>.</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">type Topology struct {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ClusterRegistryQuerySpec is used to find the all the clusters that</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // the workload may be deployed to. </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ClusterRegistry *ClusterRegistryQuerySpec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Contains the details of each subset including the target cluster name and</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // the node selector in target cluster.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Subsets []Subset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type ClusterRegistryQuerySpec struct {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Namespaces that the cluster objects reside.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // If not specified, default namespace is used.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Namespaces []string</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Selector is the label matcher to find all qualified clusters.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Selector   map[string]string</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Describe the kind and APIversion of the cluster object.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ClusterType metav1.TypeMeta</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type Subset struct {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Name string</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // The name of target cluster. The controller will validate that</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // the TargetCluster exits based on Topology.ClusterRegistry.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  TargetCluster *TargetCluster</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Indicate the node select strategy in the Subset.TargetCluster.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // If Subset.TargetCluster is not set, node selector strategy refers to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // current cluster.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  NodeSelector corev1.NodeSelector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Replicas *intstr.IntOrString </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type TargetCluster struct {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Namespace of the target cluster CRD</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Namespace string</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Target cluster name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Name string</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>A new <code>TargetCluster</code> field is added to the <code>Subset</code> API. If it presents, the
<code>NodeSelector</code> indicates the node selection logic in the target cluster. Now
UnitedDeployment controller can distribute application Pods to multiple clusters by
instantiating a <code>StatefulSet</code> workload in each target cluster with a specific
replica number (or a percentage of total replica), as illustrated in Figure 2.</p>
<p><img decoding="async" loading="lazy" alt="multi-cluster	controller" src="/zh/assets/images/uniteddeployment-2-0d3d6b19dee0e0cd3fe5bf6f121db109.png" width="658" height="547" class="img_ev3q"></p>
<p>At a first glance, UnitedDeployment looks more like a federation
controller following the design pattern of <a href="https://github.com/kubernetes-sigs/kubefed" target="_blank" rel="noopener noreferrer">Kubefed</a>,
but it isn&#x27;t. The fundamental difference is that Kubefed focuses on propagating arbitrary
object types to remote clusters instead of managing an application across clusters.
In this example, had a Kubefed style controller been used, each <code>StatefulSet</code> workload in
individual cluster would have a replica of 100. UnitedDeployment focuses more on
providing the ability of managing multiple workloads in multiple clusters on behalf
of one application, which is absent in Kubernetes community to the best of our
knowledge.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="summary">Summary<a href="#summary" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading">​</a></h2>
<p>This blog post introduces UnitedDeployment, a new controller which helps managing
application spread over multiple domains (in arbitrary clusters).
It not only allows evenly distributing Pods over AZs,
which arguably can be more efficiently done using the new Pod Topology Spread
Constraint APIs though, but also enables flexible workload deployment/rollout and
supports multi-cluster use cases in the future.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh/blog/tags/workload">workload</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh/blog/tags/uniteddeployment">uniteddeployment</a></li></ul></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/zh/blog/learning-concurrent-reconciling">Learning Concurrent Reconciling</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2019-11-10T00:00:00.000Z">2019年11月10日</time> · <!-- -->阅读需要 1 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/Fei-Guo" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://github.com/Fei-Guo.png" alt="Fei Guo"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://github.com/Fei-Guo" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp">Fei Guo</span></a></div><small class="authorTitle_nd0D" title="Maintainer of OpenKruise">Maintainer of OpenKruise</small><div class="authorSocials_rSDt"></div></div></div></div></div></header><div class="markdown"><p>The concept of controller in Kubernete is one of the most important reasons that make it successful.
Controller is the core mechanism that supports Kubernetes APIs to ensure the system reaches
the desired state. By leveraging CRDs/controllers and operators, it is fairly easy for
other systems to integrate with Kubernetes.</p>
<p>Controller runtime library and the corresponding controller tool <a href="https://book.kubebuilder.io/introduction.html" target="_blank" rel="noopener noreferrer">KubeBuilder</a>
are widely used by many developers to build their customized Kubernetes controllers. In Kruise project,
we also use Kubebuilder to generate scaffolding codes that implement the &quot;reconciling&quot; logic.
In this blog post, I will share some learnings from
Kruise controller development, particularly, about concurrent reconciling.</p>
<p>Some people may already notice that controller runtime supports concurrent reconciling.
Check for the options (<a href="https://github.com/kubernetes-sigs/controller-runtime/blob/81842d0e78f7111f0566156189806e2801e3adf1/pkg/controller/controller.go#L32" target="_blank" rel="noopener noreferrer">source</a>)
used to create new controller:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">type Options struct {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// MaxConcurrentReconciles is the maximum number of concurrent Reconciles which can be run. Defaults to 1.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	MaxConcurrentReconciles int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// Reconciler reconciles an object</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	Reconciler reconcile.Reconciler</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Concurrent reconciling is quite useful when the states of the controller&#x27;s watched objects change so
frequently that a large amount of reconcile requests are sent to and queued in the reconcile queue.
Multiple reconcile loops do help drain the reconcile queue much more quickly compared to the default single
reconcile loop case. Although this is a great feature for performance, without digging into the code,
an immediate concern that a developer may raise is that will this introduce consistency issue?
i.e., is it possible that two reconcile loops handle the same object at the same time?</p>
<p>The answer is NO, as you may expect. The &quot;magic&quot; is enforced by the workqueue
implementation in Kubernetes <code>client-go</code>, which is used by controller runtime reconcile queue.
The workqueue algorithm (<a href="https://github.com/kubernetes/client-go/blob/a57d0056dbf1d48baaf3cee876c123bea745591f/util/workqueue/queue.go#L65" target="_blank" rel="noopener noreferrer">source</a>)
is demonstrated in Figure 1.</p>
<p><img decoding="async" loading="lazy" alt="workqueue" src="/zh/assets/images/workqueue-e607402bb269a71112baa4c9870fb109.png" width="670" height="808" class="img_ev3q"></p>
<p>Basically, the workqueue uses a <code>queue</code> and two <code>sets</code> to coordinate the process of handling multiple reconciling
requests against the same object. Figure 1(a) presents the initial state of handling four reconcile requests,
two of which target the same object A. When a request arrives, the target object is first added to the <code>dirty set</code>
or dropped if it presents in <code>dirty set</code>,  and then pushed to the <code>queue</code> only if it is not presented in
<code>processing set</code>. Figure 1(b) shows the case of adding three requests consecutively.
When a reconciling loop is ready to serve a request, it gets the target object from the <code>front</code> of the queue. The
object is also added to the <code>processing set</code> and removed from the <code>dirty set</code> (Figure 1(c)).
Now if a request of the processing object arrives, the object is only added to the <code>dirty set</code>, not
to the <code>queue</code> (Figure 1(d)). This guarantees that an object is only handled by one reconciling
loop. When reconciling is done, the object is removed from the <code>processing set</code>. If the object is also
shown in the <code>dirty set</code>, it is added back to the <code>back</code> of the <code>queue</code> (Figure 1(e)).</p>
<p>The above algorithm has following implications:</p>
<ul>
<li>It avoids concurrent reconciling for the same object.</li>
<li>The object processing order can be different from arriving order even if there is only one reconciling thread.
This usually would not be a problem since the controller still reconciles to the final cluster state. However,
the out of order reconciling may cause a significant delay for a request.
<img decoding="async" loading="lazy" alt="workqueue-starve" src="/zh/assets/images/workqueue-starve-9821348cf485c42d23682a8a14fdbcb1.png" width="665" height="556" class="img_ev3q">.... For example, as illustrated in
Figure 2, assuming there is only one reconciling thread and two requests targeting the same object A arrive, one of
them will be processed and object A will be added to the <code>dirty set</code> (Figure 2(b)).
If the reconciling takes a long time and during which a large number of new reconciling requests arrive,
the queue will be filled up by the new requests (Figure 2(c)). When reconciling is done, object A will be
added to the <code>back</code> of the <code>queue</code> (Figure 2(d)). It would not be handled until all the requests coming after had been
handled, which can cause a noticeable long delay. The workaround is actually simple - <strong>USE CONCURRENT RECONCILES</strong>.
Since the cost of an idle go routine is fairly small, the overhead of having multiple reconcile threads is
low even if the controller is idle. It seems that the <code>MaxConcurrentReconciles</code> value should
be overwritten to a value larger than the default 1 (CloneSet uses 10 for example).</li>
<li>Last but not the least, reconcile requests can be dropped (if the target exists in <code>dirty set</code>). This means
that we cannot assume that the controller can track all the object state change events. Recalling a presentation
given by <a href="https://speakerdeck.com/thockin/edge-vs-level-triggered-logic" target="_blank" rel="noopener noreferrer">Tim Hockin</a>, Kubernetes controller
is level triggered, not edge triggered. It reconciles for state, not for events.</li>
</ul>
<p>Thanks for reading the post, hope it helps.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh/blog/tags/workload">workload</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh/blog/tags/reconcile">reconcile</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh/blog/tags/controller">controller</a></li></ul></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/zh/blog/workload-classification-guidance">Kruise Workload Classification Guidance</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2019-10-10T00:00:00.000Z">2019年10月10日</time> · <!-- -->阅读需要 1 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/Fei-Guo" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://github.com/Fei-Guo.png" alt="Fei Guo"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://github.com/Fei-Guo" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp">Fei Guo</span></a></div><small class="authorTitle_nd0D" title="Maintainer of OpenKruise">Maintainer of OpenKruise</small><div class="authorSocials_rSDt"></div></div></div></div><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/FillZpp" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://github.com/FillZpp.png" alt="Siyu Wang"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://github.com/FillZpp" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp">Siyu Wang</span></a></div><small class="authorTitle_nd0D" title="Maintainer of OpenKruise">Maintainer of OpenKruise</small><div class="authorSocials_rSDt"></div></div></div></div></div></header><div class="markdown"><p>Kubernetes 目前并没有为一个应用应该使用哪个控制器提供明确的指引，这尤其不利于用户理解应用和 workload 的关系。
比如说，用户通常知道什么时候应该用 <code>Job/CronJob</code> 或者 <code>DaemonSet</code>，这些 workload 的概念是非常明确的 -- 前者是为了任务类型的应用部署、后者则是面向需要分发到每个 node 上的长期运行 Pod。</p>
<p>但是另一些 workload 比如 <code>Deployment</code> 和 <code>StatefulSet</code> 之间的界限是比较模糊的。一个通过 <code>Deployment</code> 部署的应用也可以通过 <code>StatefulSet</code> 部署，<code>StatefulSet</code> 对 Pod 的 <code>OrderedReady</code> 策略并非是强制的。而且，随着 Kubernetes 社区中越来越多的自定义 controllers/operators 变的成熟，用户就越难以为自己的应用找到一个最合适的 workload 来管理，尤其是一些控制器的功能上都存在重合部分。</p>
<p>Kruise 尝试在两个方面来缓解这个问题：</p>
<ul>
<li>在 Kruise 中谨慎设计新的控制器，避免不必要的功能重复给用户来带困扰</li>
<li>为所有提供出来的 workload 控制器创建一个分类机制，方便用户更容易理解它们的使用场景。我们下面会详细描述一下，首先是 controller 命名上的规范：</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="controller-命名惯例">Controller 命名惯例<a href="#controller-命名惯例" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading">​</a></h3>
<p>一个易于理解的 controller 名字对于用户选用是非常有帮助的。经过对内外部不少 Kubernetes 用户的咨询，我们决定在 Kruise 中实行以下的命名惯例（这些惯例与目前上游的 controller 命名并不冲突）：</p>
<ul>
<li><strong>Set</strong> 后缀：这类 controller 会直接操作和管理 Pod，比如 <code>CloneSet</code>, <code>ReplicaSet</code>, <code>SidecarSet</code> 等。它们提供了 Pod 维度的多种部署、发布策略。</li>
<li><strong>Deployment</strong> 后缀：这类 controller 不会直接地操作 Pod，它们通过操作一个或多个 <strong>Set</strong> 类型的 workload 来间接管理 Pod，比如 <code>Deployment</code> 管理 <code>ReplicaSet</code> 来提供一些额外的滚动策略，以及 <code>UnitedDeployment</code> 支持管理多个 <code>StatefulSet</code>/<code>AdvancedStatefulSet</code> 来将应用部署到不同的可用区。</li>
<li><strong>Job</strong> 后缀：这类 controller 主要管理短期执行的任务，比如 <code>BroadcastJob</code> 支持将任务类型的 Pod 分发到集群中所有 Node 上。</li>
</ul>
<p><strong>Set</strong>, <strong>Deployment</strong> 和 <strong>Job</strong> 都是被 Kubernetes 社区广泛接受的概念，在 Kruise 中给他们定义了明确的扩展规范。</p>
<p>我们能否对有相同后缀的 controller 做进一步区分呢？通常来说前缀前面的名字应该是让人能一目了然的，不过也有一些情况下很难一语描述 controller 自身的行为。可以看一下 <code>StatefulSet</code> 来源的这个 <a href="https://github.com/kubernetes/kubernetes/issues/27430" target="_blank" rel="noopener noreferrer">issue</a>，社区用了四个月的时间才决定用 <code>StatefulSet</code> 这个名字代替过去的 <code>PetSet</code>，尽管新名字也让人看起来比较困惑。</p>
<p>这个例子说明了有时候一个精心计划的名字也不一定有助于标识这个 controller。因此，Kruise 并不打算解决这个问题，而是通过以下的标准来帮助对 <strong>Set</strong> 类型的 controller 分类。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="固定-pod-名字">固定 Pod 名字<a href="#固定-pod-名字" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading">​</a></h3>
<p><code>StatefulSet</code> 的一个独有的特性是支持一致的 Pod 网络和存储标识，这在本质上是通过固定 Pod 名字来实现的。Pod 名字可以用于标识网络和存储，因为它是 DNS record 的一部分，并且可以作为 PVC 的名字。既然 <code>StatefulSet</code> 下的 Pod 都是通过同一个模板创建出来的，为什么需要这个特性呢？一个常见的例子就是用于管理分布式一致性服务，比如 etcd 或 Zookeeper。这类应用需要知道集群构成的所有成员，并且在重建、发布后都需要保持原有的网络标识和磁盘数据。而像 <code>ReplicaSet</code>, <code>DaemonSet</code> 这类的控制器是面向无状态的，它们在新建 Pod 时并不会复用过去的 Pod 名字。</p>
<p>为了支持有状态，控制器的实现上会比较固定。<code>StatefulSet</code> 依赖于给每个 Pod 名字中加入一个序号，在扩缩容和滚动升级的时候都需要按照这个序号的顺序来执行。但这样一来，<code>StatefulSet</code> 也就无法做到另一些增强功能，比如：</p>
<ul>
<li>当缩小 replicas 时选择特定的 Pod 来删除，这个功能在跨多个可用区部署的时候会用到。</li>
<li>把一个存量的 Pod 接管到另一个 workload 下面（比如 <code>StatefulSet</code>）</li>
</ul>
<p>我们发现很多云原生应用并不需要这个有状态的特性来固定 Pod 名字，而 <code>StatefulSet</code> 又很难在其他方面做扩展。为了解决这个问题，Kruise 发布了一个新的控制器 <code>CloneSet</code> 来管理无状态应用，<code>CloneSet</code> 提供了对 PVC 模板的支持，并且为应用部署提供了丰富的可选策略。以下表中比较了 Advanced StatefulSet 和 CloneSet 一些方面的能力：</p>
<table><thead><tr><th>Features</th><th style="text-align:center">Advanced StatefulSet</th><th style="text-align:center">CloneSet</th></tr></thead><tbody><tr><td>PVC</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr><tr><td>Pod name</td><td style="text-align:center">Ordered</td><td style="text-align:center">Random</td></tr><tr><td>Inplace upgrade</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr><tr><td>Max unavailable</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr><tr><td>Selective deletion</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td></tr><tr><td>Selective upgrade</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td></tr><tr><td>Change Pod ownership</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td></tr></tbody></table>
<p>目前对于 Kruise 用户的建议是，如果你的应用需要固定的 Pod 名字（网络和存储标识），你可以使用 <code>Advanced StatefulSet</code>，否则 <code>CloneSet</code> 应该是 <strong>Set</strong> 类型控制器的首选。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to heading" title="Direct link to heading">​</a></h3>
<p>Kruise 会为各种 workload 选择明确的名字，本文目标是能为 Kruise 用户提供选择正确 controller 部署应用的指引。
希望对你有帮助！</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/zh/blog/tags/workload">workload</a></li></ul></div></footer></article><nav class="pagination-nav" aria-label="Blog list page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/zh/blog"><div class="pagination-nav__label">Newer Entries</div></a></nav></main></div></div></div><footer class="footer"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Documentation</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/zh/docs/installation">Getting Started</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://kubernetes.slack.com/channels/openkruise" target="_blank" rel="noopener noreferrer" class="footer__link-item">Kubernetes Slack ( #openkruise channel )<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a class="footer__link-item" href="/zh/blog/page/">DingTalk (GroupID: 23330762 )</a></li><li class="footer__item"><a class="footer__link-item" href="/zh/blog/page/">WeChat (User: openkruise )</a></li><li class="footer__item"><a href="https://shimo.im/docs/gXqmeQOYBehZ4vqo" target="_blank" rel="noopener noreferrer" class="footer__link-item">Bi-week Meeting (APAC, Chinese)<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/openkruise/kruise" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/openkruise/community/blob/master/community-membership.md" target="_blank" rel="noopener noreferrer" class="footer__link-item">Community Membership<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">
        <br>
        <strong>© 2025 The OpenKruise Authors. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage/"> Trademark Usage</a> page.</strong></div></div></div></footer></div>
</body>
</html>