---
title: Golang client
---

If you want to create/get/update/delete those OpenKruise resources in a Golang project or list-watch them using informer,
you may need a Golang client for OpenKruise.

In that way, you should use the [kruise-api](https://github.com/openkruise/kruise-api) repository,
which only includes schema definition and clientsets of Kruise.

**DO NOT** bring the whole [kruise](https://github.com/openkruise/kruise) repository as dependency into your project.

## Usage

Firstly, import `kruise-api` into your `go.mod` file (the version better to be the Kruise version you installed):

```
require github.com/openkruise/kruise-api v1.5.0
```

| Kubernetes Version in your Project | Import Kruise-api `< v0.10`    | Import Kruise-api `>= v0.10`   |
| ---------------------------------- | ---------------------------- | ---------------------------- |
| `< 1.18`                             | `v0.x.y (x <= 9)`              | `v0.x.y-legacy (x >= 10)`      |
| `>= 1.18`                            | `v0.x.y-1.18 (7 <= x <= 9)`    | `v0.x.y (x >= 10)`             |

Then, there are two ways to use `kruise-api` in your code: use it directly or with `controller-runtime`.

It is recommended that you can use it with `controller-runtime` if your project is generated by
[kubebuilder](https://github.com/kubernetes-sigs/kubebuilder) or [operator-sdk](https://github.com/operator-framework/operator-sdk),
which means `controller-runtime` is already imported in your project.
Otherwise, you may use it directly.

### Use kruise-api directly

1. New Kruise client using your rest config:

```go
import kruiseclientset "github.com/openkruise/kruise-api/client/clientset/versioned"

// cfg is the rest config defined in client-go, you should get it using kubeconfig or serviceaccount
kruiseClient := kruiseclientset.NewForConfigOrDie(cfg)
```

2. Get/List Kruise resources:

```go
cloneSet, err := kruiseClient.AppsV1alpha1().CloneSets(namespace).Get(name, metav1.GetOptions{})
cloneSetList, err := kruiseClient.AppsV1alpha1().CloneSets(namespace).List(metav1.ListOptions{})
```

3. Create/Update Kruise resources:

```go
import kruiseappsv1alpha1 "github.com/openkruise/kruise-api/apps/v1alpha1"

cloneSet := kruiseappsv1alpha1.CloneSet{
    // ...
}
err = kruiseClient.AppsV1alpha1().CloneSets(namespace).Create(&cloneSet, metav1.CreateOptions)
```

```go
// Get first
cloneSet, err := kruiseClient.AppsV1alpha1().CloneSets(namespace).Get(name, metav1.GetOptions{})
if err != nil {
    return err
}

// Modify object, such as replicas or template
cloneSet.Spec.Replicas = utilpointer.Int32Ptr(5)

// Update
// This might get conflict, should retry it
if err = kruiseClient.AppsV1alpha1().CloneSets(namespace).Update(&cloneSet, metav1.UpdateOptions); err != nil {
    return err
}
```

4. Watch Kruise resources:

```go
import kruiseinformer "github.com/openkruise/kruise-api/client/informers/externalversions"

kruiseInformerFactory := kruiseinformer.NewSharedInformerFactory(kruiseClient, 0)
kruiseInformerFactory.Apps().V1alpha1().CloneSets().Informer().AddEventHandler(...)
kruiseInformerFactory.Start(...)
```

### Use kruise-api with controller-runtime

1. Add kruise apis into the scheme in your `main.go`

```go
import kruiseapi "github.com/openkruise/kruise-api"

// ...
_ = kruiseapi.AddToScheme(scheme)
```

2. New client

This is needed when use controller-runtime client directly.

If your project is generated by [kubebuilder](https://github.com/kubernetes-sigs/kubebuilder) or [operator-sdk](https://github.com/operator-framework/operator-sdk),
you should get the client from `mgr.GetClient()` instead of the example below.

```go
import "sigs.k8s.io/controller-runtime/pkg/client"

apiClient, err := client.New(c, client.Options{Scheme: scheme})
```

3. Get/List

```go
import (
    kruiseappsv1alpha1 "github.com/openkruise/kruise-api/apps/v1alpha1"
    "sigs.k8s.io/controller-runtime/pkg/client"
)

cloneSet := kruiseappsv1alpha1.CloneSet{}
err = apiClient.Get(context.TODO(), types.NamespacedName{Namespace: namespace, Name: name}, &cloneSet)

cloneSetList := kruiseappsv1alpha1.CloneSetList{}
err = apiClient.List(context.TODO(), &cloneSetList, client.InNamespace(instance.Namespace))
```

4. Create/Update/Delete

Create a new CloneSet:

```go
import kruiseappsv1alpha1 "github.com/openkruise/kruise-api/apps/v1alpha1"

cloneSet := kruiseappsv1alpha1.CloneSet{
    // ...
}
err = apiClient.Create(context.TODO(), &cloneSet)
```

Update an existing CloneSet:

```go
import kruiseappsv1alpha1 "github.com/openkruise/kruise-api/apps/v1alpha1"

// Get first
cloneSet := kruiseappsv1alpha1.CloneSet{}
if err = apiClient.Get(context.TODO(), types.NamespacedName{Namespace: namespace, Name: name}, &cloneSet); err != nil {
    return err
}

// Modify object, such as replicas or template
cloneSet.Spec.Replicas = utilpointer.Int32Ptr(5)

// Update
// This might get conflict, should retry it
if err = apiClient.Update(context.TODO(), &cloneSet); err != nil {
    return err
}
```

5. List watch and informer

If your project is generated by [kubebuilder](https://github.com/kubernetes-sigs/kubebuilder) or [operator-sdk](https://github.com/operator-framework/operator-sdk) and get the client from `mgr.GetClient()`,
then methods like `Get`/`List` have already queried from informer instead of apiserver.
